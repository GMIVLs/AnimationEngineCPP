<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: Lists and Array in CPP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Lists and Array in CPP</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md106"></a></p>
<ul>
<li>Intro - methods for creating arrays</li>
<li>How to loop over a list-array-vector</li>
<li>C++ Standard Library for Several Containers</li>
<li>How to create an array in C++</li>
<li>what is {} for element storing is it a set or array or what</li>
<li>Declare an array</li>
</ul>
<h1><a class="anchor" id="autotoc_md107"></a>
Intro - methods for creating arrays</h1>
<ul>
<li>Arrays and lists can be created in various ways in C++, both in traditional C-style and in modern C++ style. Here's a table summarizing those:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Type</b>   </th><th class="markdownTableHeadNone"><b>Storage Location</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>C-style Static Array</b>   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Fixed-size array declared at compile time.   </td><td class="markdownTableBodyNone"><code>int arr[5] = {1, 2, 3, 4, 5};</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C-style Dynamic Array</b>   </td><td class="markdownTableBodyNone">Heap   </td><td class="markdownTableBodyNone">Array whose size is determined at runtime.   </td><td class="markdownTableBodyNone"><code>int* arr = new int[5]; ... delete[] arr;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>C++ std::array</b>   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Fixed-size array with size known at compile time.   </td><td class="markdownTableBodyNone"><code>std::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5};</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C++ std::vector</b>   </td><td class="markdownTableBodyNone">Heap (usually)   </td><td class="markdownTableBodyNone">Dynamic array that can grow/shrink at runtime.   </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>C++ std::list</b>   </td><td class="markdownTableBodyNone">Heap (usually)   </td><td class="markdownTableBodyNone">Doubly-linked list.   </td><td class="markdownTableBodyNone"><code>std::list&lt;int&gt; lst = {1, 2, 3, 4, 5};</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C++ std::forward_list</b>   </td><td class="markdownTableBodyNone">Heap (usually)   </td><td class="markdownTableBodyNone">Singly-linked list.   </td><td class="markdownTableBodyNone"><code>std::forward_list&lt;int&gt; flst = {1, 2, 3, 4, 5};</code>   </td></tr>
</table>
<p><b>Notes</b>:</p>
<ol type="1">
<li><b>C-style Static Array</b>: It's a basic fixed-size array defined on the stack. You need to know its size at compile time. The array will be destroyed automatically when it goes out of scope.</li>
<li><b>C-style Dynamic Array</b>: Uses pointers. You determine the size at runtime and must manually manage memory using <code>new</code> and <code>delete</code>.</li>
<li><b>C++ std::array</b>: A container that encapsulates fixed-size arrays. Offers benefits over C-style static arrays like bounds checking with the <code>at()</code> function.</li>
<li><b>C++ std::vector</b>: Dynamic array. Its size can change at runtime. It's one of the most used containers in C++ because of its flexibility and ease of use.</li>
<li><b>C++ std::list</b>: Doubly-linked list. Useful when you frequently need to insert or delete elements in the middle.</li>
<li><b>C++ std::forward_list</b>: Singly-linked list. Uses less memory than <code>std::list</code> but you can't access elements backwards.</li>
</ol>
<p>For the C++ style containers (<code>std::array</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::forward_list</code>), you will need to include the respective headers (<code>&lt;array&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;forward_list&gt;</code>) to use them.</p>
<h1><a class="anchor" id="autotoc_md108"></a>
How to loop over a list-array-vector</h1>
<ul>
<li>Iterating over various types of containers in C++ can be achieved through different methods. Here's a table detailing how to loop over elements in several standard C++ containers, along with descriptions, examples, and the versions of C++ in which they are supported:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Container</b>   </th><th class="markdownTableHeadNone"><b>Method</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>C++ Version</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Array</b>   </td><td class="markdownTableBodyNone">Range-based <code>for</code>   </td><td class="markdownTableBodyNone">Directly iterate over elements of a fixed-size array.   </td><td class="markdownTableBodyNone">&lsquo;int arr[5] = {1, 2, 3, 4, 5}; for(int i : arr) { cout &lt;&lt; i &lt;&lt; &rsquo; '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; C++11 onwards \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **C-Style Array** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Traditional</code>for<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Use an index-based loop for a pointer or C-style array. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>int arr[] = {1, 2, 3}; for(int i=0; i&lt;3; ++i) { cout &lt;&lt; arr[i] &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; All versions \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::vector** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Range-based</code>for<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Directly iterate over elements of a vector. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>vector&lt;int&gt; v = {1, 2, 3}; for(int i : v) { cout &lt;&lt; i &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; C++11 onwards \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::vector** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>iterator<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Use iterators provided by vector for traversal. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>for(auto it = <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">v.begin()</a>; it != v.end(); ++it) { cout &lt;&lt; *it &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; All versions \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::list** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Range-based</code>for<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Directly iterate over elements of a list. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>list&lt;int&gt; l = {1, 2, 3}; for(int i : l) { cout &lt;&lt; i &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; C++11 onwards \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::list** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>iterator<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Use iterators provided by list for traversal. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>for(auto it = <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">l.begin()</a>; it != l.end(); ++it) { cout &lt;&lt; *it &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; All versions \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::map** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Range-based</code>for<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Directly iterate over key-value pairs in a map. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>map&lt;int, string&gt; m = {{1,"a"}, {2,"b"}}; for(auto&amp; [k,v] : m) { cout &lt;&lt; k &lt;&lt; ':' &lt;&lt; v &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; C++11 for loop, C++17 for structured bindings \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::map** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>iterator<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Use iterators to traverse key-value pairs in a map. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>for(auto it = <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">m.begin()</a>; it != m.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; ':' &lt;&lt; it-&gt;second &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; All versions \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::unordered_map** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Range-based</code>for<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Directly iterate over key-value pairs in an unordered map. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>unordered_map&lt;int, string&gt; um = {{1,"a"}, {2,"b"}}; for(auto&amp; [k,v] : um) { cout &lt;&lt; k &lt;&lt; ':' &lt;&lt; v &lt;&lt; ' '; }<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; C++11 for loop, C++17 for structured bindings \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **std::unordered_map** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>iterator<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Use iterators to traverse key-value pairs in an unordered map. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>for(auto it = <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">um.begin()</a>; it != um.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; ':' &lt;&lt; it-&gt;second &lt;&lt; ' '; }`   </td><td class="markdownTableBodyNone">All versions   </td></tr>
</table>
<p><b>Notes</b>:</p>
<ol type="1">
<li><b>Range-based for loops</b>: Introduced in C++11, they allow for a more concise way of iterating over containers.</li>
<li><b>Structured Bindings</b>: Introduced in C++17, they allow you to unpack the key-value pairs in maps directly in the range-based for loop.</li>
<li><b>Iterators</b>: Are the traditional way of looping over elements in most of the STL containers.</li>
</ol>
<p>Always remember to include the appropriate headers for the containers you're using (<code>&lt;array&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;unordered_map&gt;</code>, etc.).</p>
<h1><a class="anchor" id="autotoc_md109"></a>
C++ Standard Library for Several Containers</h1>
<p>The C++ Standard Library (<code>std</code> namespace) provides a variety of container classes, each designed for different use-cases. Here's a simplified overview of some commonly used container types, presented in table form:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Data Structure</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Memory Profile</b>   </th><th class="markdownTableHeadNone"><b>Example Usage</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::array&lt;T, N&gt;</code>   </td><td class="markdownTableBodyNone">Fixed-size array. Stores <code>N</code> elements of type <code>T</code>.   </td><td class="markdownTableBodyNone">Contiguous memory, no overhead.   </td><td class="markdownTableBodyNone"><code>std::array&lt;int, 3&gt; arr = {1, 2, 3};</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::pair&lt;T1, T2&gt;</code>   </td><td class="markdownTableBodyNone">Stores exactly two values.   </td><td class="markdownTableBodyNone">Contiguous memory for the two elements.   </td><td class="markdownTableBodyNone">&lsquo;std::pair&lt;int, char&gt; p(1, 'a&rsquo;);<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::list&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Doubly-linked list. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Each node contains an element of type</code>T<code>and two pointers (prev &amp; next). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::list&lt;int&gt; lst = {1, 2, 3};<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::vector&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic array. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Pointer to dynamic memory, size, and capacity. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::vector&lt;int&gt; vec = {1, 2, 3};<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::map&lt;Key, Value&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Balanced binary tree (often a red-black tree). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Nodes containing key-value pairs, pointers to children. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::map&lt;char, int&gt; m; m['a'] = 1;<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::unordered_map&lt;Key, Value&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Hash table. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Buckets with lists/chains for collision resolution. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::unordered_map&lt;char, int&gt; um; um['a'] = 1;<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::set&lt;Key&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Like</code>std::map<code>, but only keys. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Nodes containing keys, pointers to children. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::set&lt;int&gt; s = {1, 2, 3};<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::unordered_set&lt;Key&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Like</code>std::unordered_map<code>, but only keys. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Buckets with lists/chains for collision resolution. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::unordered_set&lt;int&gt; us = {1, 2, 3};<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::deque&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Double-ended queue. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Can grow/shrink from both ends; often uses blocks of memory. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::deque&lt;int&gt; dq = {1, 2, 3};<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::stack&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; LIFO data structure. Uses another container underneath (e.g., vector, deque). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Depends on the underlying container. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::stack&lt;int&gt; st; st.push(1);<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::queue&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; FIFO data structure. Uses another container underneath (e.g., list, deque). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Depends on the underlying container. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::queue&lt;int&gt; q; q.push(1);<code>\ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::priority_queue&lt;T&gt;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap-based priority queue. Uses a vector by default. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Depends on the underlying container, often a dynamic array. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::priority_queue&lt;int&gt; pq; pq.push(1);`   </td></tr>
</table>
<ul>
<li>Note: The memory profiles provided are very high-level. The exact memory layout can differ based on system, compiler, and standard library version. The representations above are simplifications meant to convey the conceptual differences.</li>
</ul>
<h1><a class="anchor" id="autotoc_md110"></a>
How to create an array in C++</h1>
<p>Creating arrays or lists in C++ can be done in multiple ways, each having its own set of advantages and trade-offs. Here's an exhaustive table of possible methods:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Type/Method</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Memory</b>   </th><th class="markdownTableHeadNone"><b>Mutable</b>   </th><th class="markdownTableHeadNone"><b>R/W</b>   </th><th class="markdownTableHeadNone"><b>Size Specified</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Usage &amp; Common Practices</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C-style array   </td><td class="markdownTableBodyNone">Fixed-size, contiguous block of memory.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>[N]</code>)   </td><td class="markdownTableBodyNone"><code>int arr[3] = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Prefer <code>std::array</code> or <code>std::vector</code> for safety and flexibility.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic C-style array   </td><td class="markdownTableBodyNone">Dynamically-allocated array.   </td><td class="markdownTableBodyNone">Heap   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (<code>[]</code>)   </td><td class="markdownTableBodyNone"><code>int* arr = new int[3]; arr[0] = 1;</code>   </td><td class="markdownTableBodyNone">Use with caution; must manually manage memory with <code>delete[]</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::array&lt;T, N&gt;</code>   </td><td class="markdownTableBodyNone">Fixed-size, stack-allocated.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>&lt;T, N&gt;</code>)   </td><td class="markdownTableBodyNone"><code>std::array&lt;int, 3&gt; arr = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Preferred over C-style array for fixed-size lists.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::vector&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Dynamic array with auto-resizing.   </td><td class="markdownTableBodyNone">Heap &amp; Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (at creation)   </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt; vec = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Most common dynamic list in C++; handles memory management.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::list&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Doubly-linked list.   </td><td class="markdownTableBodyNone">Heap   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (at creation)   </td><td class="markdownTableBodyNone"><code>std::list&lt;int&gt; lst = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Use when frequent insertions/deletions are required in the middle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pointer to C-style array   </td><td class="markdownTableBodyNone">Points to the first element of an array.   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone"><code>int nums[3] = {1, 2, 3}; int* p = nums;</code>   </td><td class="markdownTableBodyNone">Raw pointers can be error-prone; prefer modern alternatives.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Array of pointers   </td><td class="markdownTableBodyNone">Array where each element is a pointer.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>[N]</code>)   </td><td class="markdownTableBodyNone"><code>int* arr[3]; for(int i=0; i&lt;3; i++) arr[i] = new int(i+1);</code>   </td><td class="markdownTableBodyNone">Use when needing an array of objects on the heap.   </td></tr>
</table>
<p><b>Notes:</b></p>
<ul>
<li><b>Heap &amp; Stack for <code>std::vector</code></b>: The <code>std::vector</code> object metadata (like size, capacity) resides on the stack, while the actual data is stored on the heap.</li>
<li><b>Mutable</b>: All the array types/lists mentioned in C++ are mutable by default. However, their mutability can be restricted using the <code>const</code> qualifier.</li>
<li><b>R/W</b>: All the array types/lists mentioned are readable and writable.</li>
<li><b>Memory Management</b>: Always ensure to release any heap-allocated memory to avoid memory leaks. For C-style dynamic arrays, use <code>delete[]</code> and for individual heap allocations use <code>delete</code>.</li>
<li><b>Safety</b>: Using modern C++ containers like <code>std::vector</code> or <code>std::array</code> is recommended for most use-cases due to their safety, flexibility, and the added functionalities they provide.</li>
<li><b>Size Specified</b>: This column indicates whether you must specify the size of the array/list at compile-time or not. For data structures where the size isn't specified at compile-time, it often means the size can be dynamically adjusted at runtime.</li>
<li><b>Memory Management</b>: As previously mentioned, always ensure to release any heap-allocated memory to prevent memory leaks.</li>
<li><b>Safety</b>: Using modern C++ containers is recommended for most use-cases due to their safety, flexibility, and the functionalities they provide.</li>
</ul>
<h1><a class="anchor" id="autotoc_md111"></a>
what is {} for element storing is it a set or array or what</h1>
<p>In C++, <code>{}</code> is known as the list initialization (or uniform initialization) syntax. It was introduced in C++11 to initialize objects.</p>
<ul>
<li>When you see something like this:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">arr</a>[] = {1, 2, 3};</div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
</div><!-- fragment --><p><code>{1, 2, 3}</code> is an initializer list which is being used to initialize the array <code>arr</code>.</p>
<p>Similarly, when you see:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">vec</a> = {1, 2, 3};</div>
</div><!-- fragment --><p><code>{1, 2, 3}</code> is an initializer list which is being used to initialize the vector <code>vec</code>.</p>
<p>So, <code>{}</code> is not a data type, but a way to initialize objects of various types such as arrays, vectors, sets, etc. The actual type of the data being stored depends on the type of the object being initialized.</p>
<p>In the case of:</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a> = {</div>
<div class="line">    {1, 2, 3},</div>
<div class="line">    {4, 5, 6},</div>
<div class="line">    {7, 8, 9}</div>
<div class="line">};</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a7b24a3f2f56eb1244ae69dacb4fecb6f"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a></div><div class="ttdeci">GLuint GLenum matrix</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l12040">SDL_opengl_glext.h:12040</a></div></div>
</div><!-- fragment --><p>Here, <code>{1, 2, 3}</code>, <code>{4, 5, 6}</code>, and <code>{7, 8, 9}</code> are initializer lists being used to initialize the inner vectors, and the outer <code>{...}</code> is an initializer list to initialize the outer vector. This results in a 2D vector, which you can think of as a matrix.</p>
<h1><a class="anchor" id="autotoc_md112"></a>
Declare an array</h1>
<p>C++ provides various ways to declare a list (or a sequence) of elements. Here are some common ones:</p>
<ol type="1">
<li><p class="startli"><b>C-style Array</b>: An array is a simple, fixed-size list that contains elements of the same type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">arr</a>[3] = {1, 2, 3};  <span class="comment">// Array of 3 integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::array</b>: It's a container in the Standard Library that encapsulates fixed size arrays. It's more efficient and safer than C-style arrays.</p>
<div class="fragment"><div class="line">std::array&lt;int, 3&gt; <a class="code hl_class" href="class_vector__2d.html">arr</a> = {1, 2, 3};  <span class="comment">// Array of 3 integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::vector</b>: It's a dynamic array, it can grow and shrink at runtime.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">vec</a> = {1, 2, 3};  <span class="comment">// Vector of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::list</b>: It's a doubly-linked list that allows fast insertions and deletions at both its beginning and its end.</p>
<div class="fragment"><div class="line">std::list&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">lst</a> = {1, 2, 3};  <span class="comment">// List of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::forward_list</b>: It's a singly-linked list, and unlike std::list, allows for fast insertions and deletions at its beginning only.</p>
<div class="fragment"><div class="line">std::forward_list&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">fwd_lst</a> = {1, 2, 3};  <span class="comment">// Forward list of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::deque</b>: A double-ended queue that allows fast insertions and deletions at both its beginning and its end.</p>
<div class="fragment"><div class="line">std::deque&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">dq</a> = {1, 2, 3};  <span class="comment">// Deque of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::initializer_list</b>: It's a lightweight array-like container used for list-initialization of objects.</p>
<div class="fragment"><div class="line">std::initializer_list&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">init_list</a> = {1, 2, 3};  <span class="comment">// Initializer list of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::set or std::multiset</b>: They're associative containers that contain sorted sets of unique and non-unique elements, respectively.</p>
<div class="fragment"><div class="line">std::set&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">set</a> = {1, 2, 3};  <span class="comment">// Set of unique integers</span></div>
<div class="line">std::multiset&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">mset</a> = {1, 1, 2, 2, 3, 3};  <span class="comment">// Multiset of integers</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>std::unordered_set or std::unordered_multiset</b>: They're associative containers that contain unsorted sets of unique and non-unique elements, respectively.</p>
<div class="fragment"><div class="line">std::unordered_set&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">uset</a> = {1, 2, 3};  <span class="comment">// Unordered set of unique integers</span></div>
<div class="line">std::unordered_multiset&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">umset</a> = {1, 1, 2, 2, 3, 3};  <span class="comment">// Unordered multiset of integers</span></div>
</div><!-- fragment --></li>
</ol>
<p>Each of these methods has its use cases, advantages, and drawbacks. Which one you choose depends on the requirements of your specific application. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
