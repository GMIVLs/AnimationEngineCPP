<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: Operators in depth</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Operators in depth</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md148"></a> </p>
<h1><a class="anchor" id="autotoc_md149"></a>
The operator (::)</h1>
<p>The <code>::</code> symbol in C++ is known as the "scope resolution operator". Here's a table outlining its usages:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Usage</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Best Practice</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Global Namespace</b>   </td><td class="markdownTableBodyNone">Accesses a global variable/function, typically when a local variable hides it.   </td><td class="markdownTableBodyNone"><code>int x = 10; void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a> { int x = 5; <a class="el" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> = 20; }</code>   </td><td class="markdownTableBodyNone">Only use when necessary to differentiate between global and local variables. Avoid having too many global variables in the first place.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Class Static Members</b>   </td><td class="markdownTableBodyNone">Accesses static members of a class.   </td><td class="markdownTableBodyNone"><code>class MyClass { static int x; }; int MyClass::x = 10;</code>   </td><td class="markdownTableBodyNone">Always initialize static members (especially if they have non-trivial types). It's usually done in a source (<code>.cpp</code>) file.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Outside Class Definition</b>   </td><td class="markdownTableBodyNone">Defines a member function outside the class definition.   </td><td class="markdownTableBodyNone"><code>class MyClass { void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a>; }; void MyClass::func() { }</code>   </td><td class="markdownTableBodyNone">Keep the implementation and declaration separate. Implement member functions outside the class in the source files.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Nested Class or Enum</b>   </td><td class="markdownTableBodyNone">Accesses a nested class or enum inside another class.   </td><td class="markdownTableBodyNone"><code>class Outer { class Inner { }; }; <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Outer::Inner</a> obj;</code>   </td><td class="markdownTableBodyNone">Use nested classes and enums only when the inner type has strong dependencies with the enclosing class and doesn't make sense in a broader scope.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Unambiguous Base Class Member</b>   </td><td class="markdownTableBodyNone">Specifies which base class's member to use in case of multiple inheritance.   </td><td class="markdownTableBodyNone"><code>struct A { void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a>; }; struct B { void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a>; }; struct C : A, B { void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a> { A::func(); } };</code>   </td><td class="markdownTableBodyNone">Use sparingly. Multiple inheritance can be tricky. Prefer composition or interfaces (pure virtual classes) when possible.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Global Namespace Specifier</b>   </td><td class="markdownTableBodyNone">Accesses the global namespace. Useful when working with libraries having common names.   </td><td class="markdownTableBodyNone"><code>namespace lib { void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a> { } } void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func()</a> { lib::func(); }</code>   </td><td class="markdownTableBodyNone">When using libraries, prefer using namespace qualifiers to prevent clashes and ambiguities. Avoid <code>using namespace</code> in header files.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Template Resolution</b>   </td><td class="markdownTableBodyNone">Forces the compiler to treat the name as a template.   </td><td class="markdownTableBodyNone"><code>template&lt;class T&gt; void <a class="el" href="_s_d_l__opengl__glext_8h.html#a18ae3ab36a07e388833b568cfdfa90c8">func(T)</a> { } template&lt;&gt; void func&lt;&gt;(int) { }</code>   </td><td class="markdownTableBodyNone">Use when you want to provide explicit specializations for templates. Be sure to test thoroughly, as template code can have complex interactions.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Name Qualification</b>   </td><td class="markdownTableBodyNone">Specifies a particular namespace or class to which an identifier belongs.   </td><td class="markdownTableBodyNone"><code>namespace NS { int x; } int x = NS::x;</code>   </td><td class="markdownTableBodyNone">Use namespaces to organize code and avoid name clashes. Always qualify names when it's unclear or ambiguous which version you're referring to.   </td></tr>
</table>
<ul>
<li>The <code>::</code> operator is fundamental in C++ to define and access specific parts of code within their defined scopes. Using it effectively helps manage the complexities of C++'s rich feature set and avoids ambiguities in the code. Always aim for clarity when using the scope resolution operator.</li>
</ul>
<h1><a class="anchor" id="autotoc_md150"></a>
Binary Operators</h1>
<p>Here's a continuation of the table, now including all of C++'s binary operators:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Operator</b>   </th><th class="markdownTableHeadNone"><b>Usage</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Command/Effect</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;&lt;</code>   </td><td class="markdownTableBodyNone"><code>x &lt;&lt; n</code>   </td><td class="markdownTableBodyNone"><b>Left Shift</b>: Shifts the bits of <code>x</code> to the left by <code>n</code> positions. Rightmost <code>n</code> bits are filled with zeros.   </td><td class="markdownTableBodyNone"><code>int x = 5; int result = x &lt;&lt; 2; // 20</code>   </td><td class="markdownTableBodyNone"><code>0101</code> shifted left by 2 positions becomes <code>10100</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&gt;&gt;</code>   </td><td class="markdownTableBodyNone"><code>x &gt;&gt; n</code>   </td><td class="markdownTableBodyNone"><b>Right Shift</b>: Shifts bits of <code>x</code> to the right by <code>n</code> positions. Behavior depends on sign of <code>x</code> and type.   </td><td class="markdownTableBodyNone"><code>int x = 20; int result = x &gt;&gt; 2; // 5</code>   </td><td class="markdownTableBodyNone"><code>10100</code> shifted right by 2 positions becomes <code>0101</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&amp;</code>   </td><td class="markdownTableBodyNone"><code>x &amp; y</code>   </td><td class="markdownTableBodyNone"><b>Bitwise AND</b>: Performs a bitwise AND operation on the operands.   </td><td class="markdownTableBodyNone"><code>int result = 5 &amp; 3; // result is 1</code>   </td><td class="markdownTableBodyNone"><code>0101</code> AND <code>0011</code> results in <code>0001</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>\|</code>   </td><td class="markdownTableBodyNone"><code>x \| y</code>   </td><td class="markdownTableBodyNone"><b>Bitwise OR</b>: Performs a bitwise OR operation on the operands.   </td><td class="markdownTableBodyNone"><code>int result = 5 \| 3; // result is 7</code>   </td><td class="markdownTableBodyNone"><code>0101</code> OR <code>0011</code> results in <code>0111</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>^</code>   </td><td class="markdownTableBodyNone"><code>x ^ y</code>   </td><td class="markdownTableBodyNone"><b>Bitwise XOR</b>: Performs a bitwise exclusive OR operation on the operands.   </td><td class="markdownTableBodyNone"><code>int result = 5 ^ 3; // result is 6</code>   </td><td class="markdownTableBodyNone"><code>0101</code> XOR <code>0011</code> results in <code>0110</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>~</code>   </td><td class="markdownTableBodyNone"><code>~x</code>   </td><td class="markdownTableBodyNone"><b>Bitwise NOT</b>: Flips all the bits of the operand.   </td><td class="markdownTableBodyNone"><code>int result = ~5; // platform-dependent</code>   </td><td class="markdownTableBodyNone">Flips each bit of <code>0101</code>, result might be <code>1010</code> for an 8-bit int.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>+</code>   </td><td class="markdownTableBodyNone"><code>x + y</code>   </td><td class="markdownTableBodyNone"><b>Addition</b>: Adds two numbers.   </td><td class="markdownTableBodyNone"><code>int result = 5 + 3; // result is 8</code>   </td><td class="markdownTableBodyNone">Adds 5 and 3, results in 8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-</code>   </td><td class="markdownTableBodyNone"><code>x - y</code>   </td><td class="markdownTableBodyNone"><b>Subtraction</b>: Subtracts second operand from the first.   </td><td class="markdownTableBodyNone"><code>int result = 5 - 3; // result is 2</code>   </td><td class="markdownTableBodyNone">Subtracts 3 from 5, results in 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>*</code>   </td><td class="markdownTableBodyNone"><code>x * y</code>   </td><td class="markdownTableBodyNone"><b>Multiplication</b>: Multiplies two numbers.   </td><td class="markdownTableBodyNone"><code>int result = 5 * 3; // result is 15</code>   </td><td class="markdownTableBodyNone">Multiplies 5 by 3, results in 15    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>/</code>   </td><td class="markdownTableBodyNone"><code>x / y</code>   </td><td class="markdownTableBodyNone"><b>Division</b>: Divides the first operand by the second.   </td><td class="markdownTableBodyNone"><code>int result = 5 / 3; // result is 1</code>   </td><td class="markdownTableBodyNone">Divides 5 by 3, results in 1 (integer division)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>%</code>   </td><td class="markdownTableBodyNone"><code>x % y</code>   </td><td class="markdownTableBodyNone"><b>Modulo</b>: Returns the remainder of the division of the first operand by the second.   </td><td class="markdownTableBodyNone"><code>int result = 5 % 3; // result is 2</code>   </td><td class="markdownTableBodyNone">Divides 5 by 3, remainder is 2   </td></tr>
</table>
<p><b>Notes</b>:</p>
<ol type="1">
<li><b>Division by Zero</b>: Both the <code>/</code> and <code>%</code> operators will cause undefined behavior if the second operand is zero.</li>
<li><b>Bitwise Operations</b>: The bitwise operations (<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) operate on the individual bits of their operands.</li>
<li><b>Signedness</b>: The behavior of the shift operators and the <code>~</code> operator can vary depending on whether the operands are signed or unsigned. Always be cautious and understand the context in which you're using them.</li>
<li><b>Operator Overloading</b>: C++ allows user-defined types (e.g., classes) to provide custom implementations for these operators. This means they can perform different operations when used with objects of those types.</li>
</ol>
<p><b>Notes</b>:</p>
<ol type="1">
<li><b>Division by Zero</b>: Both the <code>/</code> and <code>%</code> operators will cause undefined behavior if the second operand is zero.</li>
<li><b>Bitwise Operations</b>: The bitwise operations (<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) operate on the individual bits of their operands.</li>
<li><b>Signedness</b>: The behavior of the shift operators and the <code>~</code> operator can vary depending on whether the operands are signed or unsigned. Always be cautious and understand the context in which you're using them.</li>
<li><b>Operator Overloading</b>: C++ allows user-defined types (e.g., classes) to provide custom implementations for these operators. This means they can perform different operations when used with objects of those types.</li>
</ol>
<h1><a class="anchor" id="autotoc_md151"></a>
Usage of Modulo operators %</h1>
<ul>
<li>The modulo operator <code>%</code> in C++ is primarily used to calculate the remainder of integer division. However, it has a wide variety of applications due to this basic functionality. Here's a table illustrating some common use cases:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Usage</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Description</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Basic Remainder Calculation   </td><td class="markdownTableBodyNone"><code>int result = 11 % 3; // result is 2</code>   </td><td class="markdownTableBodyNone">Directly computes the remainder of 11 divided by 3. The result is <code>2</code> because 11 divided by 3 gives a quotient of <code>3</code> with a remainder of <code>2</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Looping/Cycling over Array Elements   </td><td class="markdownTableBodyNone"><code>int arr[5]; int i = 7; int pos = i % 5; // pos is 2</code>   </td><td class="markdownTableBodyNone">If you need to access elements in a cyclic manner, the modulo operator can be used. Here, accessing the 7th element of a 5-element array actually accesses the 2nd element.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Datetime (Hours)   </td><td class="markdownTableBodyNone"><code>int hours = 26; int dayHours = hours % 24; // dayHours is 2</code>   </td><td class="markdownTableBodyNone">For time representation, if you exceed 24 hours, the modulo can be used to determine the hour of the next day. Here, 26 hours is equivalent to 2 hours into the next day.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Datetime (Minutes, Seconds)   </td><td class="markdownTableBodyNone"><code>int mins = 130; int hourMins = mins % 60; // hourMins is 10</code>   </td><td class="markdownTableBodyNone">Similarly, for minutes or seconds, exceeding 60 can be wrapped using modulo. Here, 130 minutes is 2 hours and 10 minutes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Checking for Even/Odd Numbers   </td><td class="markdownTableBodyNone"><code>bool isEven = (num % 2 == 0);</code>   </td><td class="markdownTableBodyNone">The modulo operator can determine if a number is even or odd. If a number modulo 2 is <code>0</code>, it's even; otherwise, it's odd.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ensuring Values within a Range   </td><td class="markdownTableBodyNone"><code>int val = -3; int positiveVal = (val + N) % N;</code>   </td><td class="markdownTableBodyNone">If you want to ensure a number stays within a specific range (0 to N-1), modulo can be helpful, especially when dealing with negative numbers.   </td></tr>
</table>
<p><b>Notes</b>:</p>
<ol type="1">
<li><b>Be Cautious with Negative Numbers</b>: The behavior of the modulo operator with negative operands can differ between programming languages. In C++, <code>-3 % 5</code> will yield <code>-3</code>, not <code>2</code>. If you want a "positive" result, you might need to adjust the operand or the result as shown in the last usage example.</li>
<li><b>Non-Integer Types</b>: In C++, the modulo operator is defined only for integral types. It's not directly applicable to floating-point types, although libraries or custom logic can be used to achieve similar effects.</li>
<li><b>Zero Division</b>: Just like with division, using the modulo operator with a denominator of <code>0</code> will result in undefined behavior in C++. Always ensure your denominator is non-zero. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
