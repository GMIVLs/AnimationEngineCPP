<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: HOW CPP WORKS - Deep Dive</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">HOW CPP WORKS - Deep Dive</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md64"></a> <b>Table of Contents</b></p>
<ul>
<li>HOW CPP WORKS - Deep Dive<ul>
<li>Main C++ Working<ul>
<li>The key terms are:</li>
</ul>
</li>
<li>ASCII diagram to illustrate the process:<ul>
<li>Explanation of steps:</li>
</ul>
</li>
<li>Where the translation unit and where is the object file</li>
<li>Static Linking with Third Party Library</li>
<li>Dynamic Linking</li>
<li>Files Types in Building Process</li>
<li>Can a Project has several translation units?</li>
<li>Header files</li>
<li>Guards for Directives (#include)</li>
<li>Q&amp;A Sessionn<ul>
<li>Question -1</li>
<li>Question -2</li>
<li>Question -3</li>
<li>Question -4</li>
<li>Question -5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md65"></a>
Main C++ Working</h1>
<p>When you're working with C++ and you have a set of source files like <code><a class="el" href="main_8cpp.html">main.cpp</a></code>, <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code>, and a header file <code>lib.h</code>, you're dealing with multiple steps of compilation and linking.</p>
<p>Here's what happens step-by-step:</p>
<ol type="1">
<li><b>Preprocessing</b>: Before actual compilation, the preprocessor handles directives such as <code>#include</code>, <code>#define</code>, and <code>#ifdef</code>. For your <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code>, the <code>#include "lib.h"</code> directive would cause the content of <code>lib.h</code> to be included (copied) into each of those cpp files. This step doesn't produce any files you interact with; it's done in-memory before compilation.</li>
<li><b>Compilation</b>: Each cpp file is compiled separately. The compiler translates <code><a class="el" href="main_8cpp.html">main.cpp</a></code> into <code>main.o</code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> into <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>. These are called object files. This is the step where the compiler checks for syntax errors and other language rules. After this step, each object file contains machine code, but it's not yet executable because it might contain unresolved symbols that it expects to find in other object files.<ul>
<li><code>main.o</code> is a translation unit corresponding to <code><a class="el" href="main_8cpp.html">main.cpp</a></code> after preprocessing.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code> is a translation unit corresponding to <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> after preprocessing.</li>
</ul>
</li>
<li><b>Linking</b>: The linker takes all object files (<code>main.o</code>, <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>) and resolves any references between them. If <code><a class="el" href="main_8cpp.html">main.cpp</a></code> calls a function that's implemented in <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code>, the linker connects these two parts together. The result is an executable file (like <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">a.out</a></code> on Unix systems or <code>main.exe</code> on Windows).</li>
<li><b>Execution</b>: You can now run the executable file on your computer. If there were no linking errors, and your code is correctly written, it should execute and produce whatever output your program is designed to produce.</li>
</ol>
<h2><a class="anchor" id="autotoc_md66"></a>
The key terms are:</h2>
<ul>
<li><b>Source files</b>: The original <code>.cpp</code> and <code>.h</code> files you write.</li>
<li><b>Translation units</b>: The combination of a source file and all the headers it includes, after preprocessing.</li>
<li><b>Object files</b>: The machine code output from compiling a translation unit, typically with <code>.o</code> or <code>.obj</code> extension.</li>
<li><b>Executable</b>: The final runnable program created by the linker.</li>
</ul>
<p>The resulting executable is what you run on your computer. The intermediary files, like the object files, are usually not needed once the final linking is done, unless you're doing incremental compilation.</p>
<h1><a class="anchor" id="autotoc_md67"></a>
ASCII diagram to illustrate the process:</h1>
<div class="fragment"><div class="line"> Step 1: Preprocessing</div>
<div class="line">----------------------------</div>
<div class="line">main.cpp      lib.cpp     lib.h</div>
<div class="line">  |             |          |</div>
<div class="line">  |             |          |</div>
<div class="line">  | #include    |          |</div>
<div class="line">  v             |          |</div>
<div class="line">&lt;iostream&gt;      |          |</div>
<div class="line">  |             |          |</div>
<div class="line">  | #include &quot;lib.h&quot;       |</div>
<div class="line">  |------------------------|</div>
<div class="line">  |             |</div>
<div class="line">  |             | #include &quot;lib.h&quot;</div>
<div class="line">  |             |-----------------|</div>
<div class="line">  |             |</div>
<div class="line">  v             v</div>
<div class="line">main.i        lib.i</div>
<div class="line"> </div>
<div class="line">Step 2: Compilation</div>
<div class="line">----------------------------</div>
<div class="line">main.i        lib.i</div>
<div class="line">  |             |</div>
<div class="line">  | Compiles    | Compiles</div>
<div class="line">  v             v</div>
<div class="line">main.o        lib.o</div>
<div class="line"> </div>
<div class="line">Step 3: Linking</div>
<div class="line">----------------------------</div>
<div class="line">main.o        lib.o</div>
<div class="line">  |             |</div>
<div class="line">  |             |</div>
<div class="line">  |   Linker    |</div>
<div class="line">  |-------------|</div>
<div class="line">        |</div>
<div class="line">        v</div>
<div class="line">     program</div>
<div class="line">     (a.out)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
Explanation of steps:</h2>
<ol type="1">
<li><b>Preprocessing</b>:<ul>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> includes <code>iostream</code> and <code>lib.h</code>. The content of <code>iostream</code> and <code>lib.h</code> is effectively copied into <code><a class="el" href="main_8cpp.html">main.cpp</a></code> to create <code>main.i</code>.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> includes <code>lib.h</code>. The content of <code>lib.h</code> is copied into <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> to create <code>lib.i</code>.</li>
<li>The <code>.i</code> files are preprocessed source files, which you usually don't see as they are intermediate and kept in memory.</li>
</ul>
</li>
<li><b>Compilation</b>:<ul>
<li><code>main.i</code> is compiled into an object file <code>main.o</code>.</li>
<li><code>lib.i</code> is compiled into an object file <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>.</li>
<li>The <code>.o</code> files contain the compiled machine code, but external references are not resolved yet.</li>
</ul>
</li>
<li><b>Linking</b>:<ul>
<li>The linker takes all the object files (<code>main.o</code>, <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>) and resolves symbols, references, etc., to produce the final executable (<code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">a.out</a></code> on Unix-like systems).</li>
</ul>
</li>
</ol>
<p>Each <code>.cpp</code> file is processed independently until the linking stage, where the generated object files are combined to create the final executable.</p>
<h1><a class="anchor" id="autotoc_md69"></a>
Where the translation unit and where is the object file</h1>
<p>the ASCII diagram updated to include where the translation units and object files come into play:</p>
<div class="fragment"><div class="line"> Step 1: Preprocessing</div>
<div class="line">----------------------------</div>
<div class="line">main.cpp      lib.cpp     lib.h</div>
<div class="line">  |             |          |</div>
<div class="line">  | #include    | #include |</div>
<div class="line">  |-------------|----------|</div>
<div class="line">  |             |          |</div>
<div class="line">  |             |          |</div>
<div class="line">  v             v          |</div>
<div class="line">main.i        lib.i       |</div>
<div class="line">(Translation (Translation |</div>
<div class="line"> Unit)        Unit)       |</div>
<div class="line"> </div>
<div class="line"> Step 2: Compilation</div>
<div class="line">----------------------------</div>
<div class="line">main.i        lib.i</div>
<div class="line">(Translation (Translation</div>
<div class="line"> Unit)        Unit)</div>
<div class="line">  |             |</div>
<div class="line">  | Compiles    | Compiles</div>
<div class="line">  |             |</div>
<div class="line">  v             v</div>
<div class="line">main.o        lib.o</div>
<div class="line">(Object       (Object</div>
<div class="line"> File)        File)</div>
<div class="line"> </div>
<div class="line"> Step 3: Linking</div>
<div class="line">----------------------------</div>
<div class="line">main.o        lib.o</div>
<div class="line">(Object       (Object</div>
<div class="line"> File)        File)</div>
<div class="line">  |             |</div>
<div class="line">  |             |</div>
<div class="line">  |   Linker    |</div>
<div class="line">  |-------------|</div>
<div class="line">        |</div>
<div class="line">        v</div>
<div class="line">     program</div>
<div class="line">   (Executable)</div>
</div><!-- fragment --><p><b>Explanation of additions:</b></p>
<ul>
<li><b>Translation Units</b>: After preprocessing, <code>main.i</code> and <code>lib.i</code> are the translation units. These consist of the source code in <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code>, with the contents of <code>lib.h</code> and any other included headers (like <code>iostream</code> for <code><a class="el" href="main_8cpp.html">main.cpp</a></code>) directly inserted in place of the <code>#include</code> directives.</li>
<li><b>Object Files</b>: The result of compiling each translation unit is an object file. <code>main.o</code> is the object file for <code>main.i</code>, and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code> is the object file for <code>lib.i</code>. These contain the compiled code in a binary format, but not yet linked to other object files.</li>
</ul>
<h1><a class="anchor" id="autotoc_md70"></a>
Static Linking with Third Party Library</h1>
<p>I'll illustrate how static linking with a third-party library works across different platforms. Let's assume we have a static library named <code>libthirdparty</code>.</p>
<p>On Windows, static libraries typically have a <code>.lib</code> extension, on macOS and Linux, the extension is usually <code>.a</code>.</p>
<p>Here's the updated ASCII diagram:</p>
<div class="fragment"><div class="line"> Step 1: Preprocessing</div>
<div class="line">----------------------------</div>
<div class="line">main.cpp      lib.cpp     lib.h     libthirdparty (Third-Party Library)</div>
<div class="line">  |             |          |              |</div>
<div class="line">  | #include    | #include |              |</div>
<div class="line">  |-------------|----------|              |</div>
<div class="line">  |             |          |              |</div>
<div class="line">  |             |          |              |</div>
<div class="line">  v             v          |              |</div>
<div class="line">main.i        lib.i       |           libthirdparty.lib (Windows)</div>
<div class="line">(Translation (Translation |           libthirdparty.a   (macOS/Linux)</div>
<div class="line"> Unit)        Unit)       |           (Static Library)</div>
<div class="line">                           |</div>
<div class="line"> Step 2: Compilation</div>
<div class="line">----------------------------</div>
<div class="line">main.i        lib.i</div>
<div class="line">(Translation (Translation</div>
<div class="line"> Unit)        Unit)</div>
<div class="line">  |             |</div>
<div class="line">  | Compiles    | Compiles</div>
<div class="line">  |             |</div>
<div class="line">  v             v</div>
<div class="line">main.o        lib.o</div>
<div class="line">(Object       (Object</div>
<div class="line"> File)        File)</div>
<div class="line"> </div>
<div class="line"> Step 3: Linking (with Static Library)</div>
<div class="line">----------------------------</div>
<div class="line">main.o        lib.o       libthirdparty.lib (Windows)</div>
<div class="line">(Object       (Object     libthirdparty.a   (macOS/Linux)</div>
<div class="line"> File)        File)       (Static Library)</div>
<div class="line">  |             |              |</div>
<div class="line">  |             |              |</div>
<div class="line">  |   Linker    |--------------|</div>
<div class="line">  |-------------|</div>
<div class="line">        |</div>
<div class="line">        v</div>
<div class="line">     program.exe (Windows)</div>
<div class="line">     program     (macOS/Linux)</div>
<div class="line">   (Executable)</div>
</div><!-- fragment --><p><b>Explanation of additions:</b></p>
<ul>
<li><b>Static Library</b>: The third-party static library <code>libthirdparty</code> is shown here before linking. It is included by the linker, not by the preprocessor, so it doesn't go through the preprocessing or compilation stages that your own source code does.</li>
<li><b>Linking with Static Library</b>: During the linking step, the static library (<code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">libthirdparty.lib</a></code> for Windows, <code>libthirdparty.a</code> for macOS and Linux) is combined with your object files (<code>main.o</code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>) to produce the final executable. Static linking copies the library code into your executable at build time, so the library becomes part of your application.</li>
</ul>
<p>When you compile and link your program, you'll need to tell the compiler/linker where to find the <code>libthirdparty</code> library files and how to include them. This is typically done through command-line arguments or project settings in your development environment.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Dynamic Linking</h1>
<p>Dynamic linking involves linking against shared libraries (also known as Dynamic Link Libraries (DLL) on Windows or Shared Objects (.so) on Unix-like systems such as Linux and macOS). Unlike static libraries, dynamic libraries are not embedded into the executable at link time; instead, they are loaded at runtime.</p>
<p>Here’s how the ASCII diagram would look with dynamic linking:</p>
<div class="fragment"><div class="line"> Step 1: Preprocessing</div>
<div class="line">----------------------------</div>
<div class="line">main.cpp      lib.cpp     lib.h     libthirdparty (Third-Party Library)</div>
<div class="line">  |             |          |              |</div>
<div class="line">  | #include    | #include |              |</div>
<div class="line">  |-------------|----------|              |</div>
<div class="line">  |             |          |              |</div>
<div class="line">  |             |          |              |</div>
<div class="line">  v             v          |              |</div>
<div class="line">main.i        lib.i       |           libthirdparty.dll (Windows)</div>
<div class="line">(Translation (Translation |           libthirdparty.so  (macOS/Linux)</div>
<div class="line"> Unit)        Unit)       |           (Dynamic Library)</div>
<div class="line">                           |</div>
<div class="line"> Step 2: Compilation</div>
<div class="line">----------------------------</div>
<div class="line">main.i        lib.i</div>
<div class="line">(Translation (Translation</div>
<div class="line"> Unit)        Unit)</div>
<div class="line">  |             |</div>
<div class="line">  | Compiles    | Compiles</div>
<div class="line">  |             |</div>
<div class="line">  v             v</div>
<div class="line">main.o        lib.o</div>
<div class="line">(Object       (Object</div>
<div class="line"> File)        File)</div>
<div class="line"> </div>
<div class="line"> Step 3: Linking (with Dynamic Library)</div>
<div class="line">----------------------------</div>
<div class="line">main.o        lib.o       libthirdparty.dll (Windows)</div>
<div class="line">(Object       (Object     libthirdparty.so  (macOS/Linux)</div>
<div class="line"> File)        File)       (Dynamic Library)</div>
<div class="line">  |             |              |</div>
<div class="line">  |             |              |</div>
<div class="line">  |   Linker    |--------------|</div>
<div class="line">  |-------------|              |</div>
<div class="line">        |                      |</div>
<div class="line">        v                      v</div>
<div class="line">     program.exe           Loaded at</div>
<div class="line">     program               Runtime</div>
<div class="line">   (Executable)</div>
</div><!-- fragment --><p><b>Explanation of changes for Dynamic Linking:</b></p>
<ul>
<li><b>Dynamic Library</b>: <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">libthirdparty.dll</a></code> for Windows or <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">libthirdparty.so</a></code> for Unix-like systems represents the dynamic library. The dynamic library itself isn't included in the linking step to be part of the executable. Instead, information about where to find the dynamic library at runtime is included.</li>
<li><b>Linking with Dynamic Library</b>: During the linking phase, the executable is prepared to call into the dynamic library. It knows the names of the functions it needs to call, but not where they are located in memory.</li>
<li><b>Runtime</b>: When the program runs, the operating system loads the dynamic library into memory, and the program uses the OS-provided mechanisms to call functions within the dynamically linked library.</li>
</ul>
<p><b>Note*</b>: that when distributing your application, you need to ensure that the target system has access to the required dynamic library at the correct version, or the application won't run. This is often managed by installing the library in a standard location, using the operating system's package management, or by distributing the library alongside the application with appropriate paths set.</p>
<h1><a class="anchor" id="autotoc_md72"></a>
Files Types in Building Process</h1>
<p>Can you make a table for all files types that is generated in this process? Here is a table summarizing the different file types generated during the C++ compilation process and their meanings:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Extension   </th><th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.cpp</code>   </td><td class="markdownTableBodyNone">Cross-Platform   </td><td class="markdownTableBodyNone">C++ Source file which contains the code written by the programmer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.h</code>   </td><td class="markdownTableBodyNone">Cross-Platform   </td><td class="markdownTableBodyNone">Header file which typically contains function declarations and macros.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.hpp</code>   </td><td class="markdownTableBodyNone">Cross-Platform   </td><td class="markdownTableBodyNone">C++ Header file, similar to <code>.h</code> but specifically for C++ declarations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.i</code>   </td><td class="markdownTableBodyNone">Cross-Platform   </td><td class="markdownTableBodyNone">Preprocessed source file (rarely seen; often a temporary file).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.o</code>   </td><td class="markdownTableBodyNone">Unix-like   </td><td class="markdownTableBodyNone">Object file, contains machine code generated by the compiler.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.obj</code>   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Object file, contains machine code generated by the compiler.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.a</code>   </td><td class="markdownTableBodyNone">Unix-like   </td><td class="markdownTableBodyNone">Static library, an archive of object files for static linking.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.lib</code>   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Static library file or an import library for dynamic linking.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.so</code>   </td><td class="markdownTableBodyNone">Unix-like   </td><td class="markdownTableBodyNone">Shared Object, dynamic library loaded at runtime.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.dll</code>   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Dynamic Link Library, dynamic library loaded at runtime.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.exe</code>   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Executable file, the final runnable program.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(No extension)   </td><td class="markdownTableBodyNone">Unix-like   </td><td class="markdownTableBodyNone">Executable file, the final runnable program.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>.dylib</code>   </td><td class="markdownTableBodyNone">macOS   </td><td class="markdownTableBodyNone">Dynamic library, similar to <code>.so</code>, used in macOS.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>.dSYM</code>   </td><td class="markdownTableBodyNone">macOS   </td><td class="markdownTableBodyNone">Debug symbols file, contains debug information for use in a debugger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">`.pdb**   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone">Program Database, stores debugging information about a program.   </td></tr>
</table>
<p><b>Note*</b>: This table does not cover every possible file type associated with C++ development, such as those used by various Integrated Development Environments (IDEs) for project management or by other tools for resources, but it does cover the main file types produced and used during the build process.</p>
<ul>
<li>Here is an expanded version of the table with <code>.dylib</code> included and other relevant file types:</li>
</ul>
<p>This table includes file extensions for debug symbols which are also an important part of the development process, especially when debugging applications. Debug symbols are generated alongside executables and libraries to provide a mapping from the binary code to the original source code, making it possible to step through the source code during debugging sessions.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Can a Project has several translation units?</h1>
<p>Yes, a project can have several translation units. In fact, it's quite common in larger C++ projects. A translation unit is essentially a single compiled source file, but it includes all the headers and included source files that are brought in via <code>#include</code> preprocessor directives. Here's how it works:</p>
<ol type="1">
<li><b>Each <code>.cpp</code> File Is a Separate Translation Unit</b>: When you compile a <code>.cpp</code> file, the compiler processes it along with all the included headers and generates one object file (<code>.o</code> or <code>.obj</code>) per <code>.cpp</code> file. Each of these is a translation unit.</li>
<li><b>Headers Are Not Translation Units</b>: Header files (<code>.h</code> or <code>.hpp</code>) are not compiled on their own; they are included in one or more <code>.cpp</code> files. They become part of a translation unit when they are included and processed in a <code>.cpp</code> file.</li>
<li><b>Linking Translation Units</b>: After all the individual translation units have been compiled into object files, a linker combines all the object files into a single executable (or library). If there are multiple <code>.cpp</code> files, the linker resolves cross-references between them.</li>
</ol>
<p>Here's an example with multiple <code>.cpp</code> files in a project:</p>
<ul>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> includes <code>main.h</code> and possibly other headers.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">utils.cpp</a></code> includes <code>utils.h</code>.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">network.cpp</a></code> includes <code>network.h</code>.</li>
</ul>
<p>Each of these <code>.cpp</code> files will be compiled into its own object file:</p>
<ul>
<li><code>main.o</code></li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">utils.o</a></code></li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">network.o</a></code></li>
</ul>
<p>These object files are then linked together to create the final executable program. Each <code>.cpp</code> file and the headers it includes form separate translation units during the compilation process.</p>
<p>Here's a table defining various terms related to the C++ build process:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term   </th><th class="markdownTableHeadNone">Meaning   </th><th class="markdownTableHeadNone">Associated File Extension(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Source File   </td><td class="markdownTableBodyNone">Contains code written by the programmer. It's the starting point of the compilation process.   </td><td class="markdownTableBodyNone"><code>.cpp</code>, <code>.cc</code>, <code>.cxx</code>, <code>.c++</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Header File   </td><td class="markdownTableBodyNone">Used to declare the structure of the program. Contains declarations of functions, classes, etc.   </td><td class="markdownTableBodyNone"><code>.h</code>, <code>.hpp</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Translation Unit   </td><td class="markdownTableBodyNone">The result of processing a source file and all its included headers and source files.   </td><td class="markdownTableBodyNone">N/A (conceptual, corresponds to a <code>.cpp</code> file pre-compilation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Object File   </td><td class="markdownTableBodyNone">Contains machine code output by the compiler. It's what the linker uses to create the executable.   </td><td class="markdownTableBodyNone"><code>.o</code> (Unix-like), <code>.obj</code> (Windows)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Static Library   </td><td class="markdownTableBodyNone">An archive of object files, linked into an executable at build time.   </td><td class="markdownTableBodyNone"><code>.a</code> (Unix-like), <code>.lib</code> (Windows)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic Library   </td><td class="markdownTableBodyNone">A library loaded at runtime, allowing for shared code across programs.   </td><td class="markdownTableBodyNone"><code>.so</code> (Unix-like), <code>.dll</code> (Windows), <code>.dylib</code> (macOS)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Executable   </td><td class="markdownTableBodyNone">The final runnable program file resulting from the linking process.   </td><td class="markdownTableBodyNone"><code>.exe</code> (Windows), (No extension or <code>.out</code>) (Unix-like), <code>.app</code> (macOS)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Preprocessed File   </td><td class="markdownTableBodyNone">An intermediate file created after the preprocessing step. It's not usually saved.   </td><td class="markdownTableBodyNone"><code>.i</code> (rarely used as a file extension)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Standard Library   </td><td class="markdownTableBodyNone">A collection of classes and functions prescribed by the language standard.   </td><td class="markdownTableBodyNone">N/A (implemented in compilers, may be part of runtime)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Import Library   </td><td class="markdownTableBodyNone">Used on some platforms like Windows to describe a dynamic library's interface to the linker.   </td><td class="markdownTableBodyNone"><code>.lib</code> (Windows)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Shared Object   </td><td class="markdownTableBodyNone">The Linux term for a dynamic library.   </td><td class="markdownTableBodyNone"><code>.so</code> (Unix-like)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic Link Library   </td><td class="markdownTableBodyNone">The Windows term for a dynamic library.   </td><td class="markdownTableBodyNone"><code>.dll</code> (Windows)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Archive File   </td><td class="markdownTableBodyNone">A static library in Unix-like systems.   </td><td class="markdownTableBodyNone"><code>.a</code> (Unix-like)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Debug Symbols File   </td><td class="markdownTableBodyNone">Contains debug information, mapping the executable to the source code for debugging.   </td><td class="markdownTableBodyNone"><code>.pdb</code> (Windows), <code>.dSYM</code> (macOS)   </td></tr>
</table>
<p>This table includes terms that represent both physical files (with extensions) and conceptual aspects of the build process (like the translation unit). The standard library files are usually part of the runtime and are typically pre-compiled with the compiler, not directly visible in the project file structure.</p>
<h1><a class="anchor" id="autotoc_md74"></a>
Header files</h1>
<p>How the header will not repeated among the translation units in case it is mentioned twice</p>
<ul>
<li>To prevent a header from being included multiple times within the same translation unit, which can cause errors due to redefinition, C++ uses an "include guard." An include guard is a preprocessor technique that ensures a header file is only included once no matter how many times it's requested by the preprocessor.</li>
</ul>
<p>Here's how include guards typically work:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef HEADER_NAME_H</span></div>
<div class="line"><span class="preprocessor">#define HEADER_NAME_H</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// declarations and definitions</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HEADER_NAME_H</span></div>
</div><!-- fragment --><ul>
<li>The <code>#ifndef</code> directive checks if <code>HEADER_NAME_H</code> (a unique macro name) has been defined. If not, it defines <code>HEADER_NAME_H</code> and allows the inclusion of the header's contents. The next time the preprocessor encounters this header, <code>HEADER_NAME_H</code> will already be defined, so the contents within the <code>#ifndef</code> and <code>#endif</code> block will be ignored.</li>
<li>Include guards are standard practice in C++ programming and are essential for preventing multiple inclusions of the same header in a single translation unit.</li>
<li>When multiple translation units include the same header, each translation unit is compiled separately, so the include guard only prevents multiple inclusions within each translation unit. The linker is responsible for handling the definitions when the separate translation units are combined into a single executable or library, ensuring there are no duplicate symbols.</li>
</ul>
<h1><a class="anchor" id="autotoc_md75"></a>
Guards for Directives (#include)</h1>
<p>Yes, include guards are also relevant for standard library headers like <code>&lt;iostream&gt;</code>. However, standard library implementations handle this internally so that when you include a standard library header like <code>&lt;iostream&gt;</code> in multiple source files (translation units), each one will only include it once during compilation. This is to prevent multiple definitions and other issues that might arise from including the same declarations multiple times in a single translation unit.</p>
<p>In your example, including <code>&lt;iostream&gt;</code> in both <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> works without issues:</p>
<ul>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> includes <code>&lt;iostream&gt;</code>. The preprocessor includes the content of <code>&lt;iostream&gt;</code> in the translation unit that is being compiled from <code><a class="el" href="main_8cpp.html">main.cpp</a></code>.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> includes <code>&lt;iostream&gt;</code>. The same process occurs separately, as <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> is another translation unit.</li>
</ul>
<p>After preprocessing and compilation, both <code>main.o</code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code> will have their own compiled code from <code>&lt;iostream&gt;</code>. The linker then takes over and ensures that any standard library code is properly managed, and the final executable has only one set of definitions for the standard library functions used, regardless of how many times they were included in different translation units.</p>
<p>The C++ Standard Library and its headers are designed to be included in multiple translation units; it's a fundamental part of supporting modular compilation.</p>
<h1><a class="anchor" id="autotoc_md76"></a>
Q&amp;A Sessionn</h1>
<h2><a class="anchor" id="autotoc_md77"></a>
Question -1</h2>
<ul>
<li>Explain more about the translation units<ul>
<li>Is it possible to make two or more translation units in single project? Assume I am calling them all into <a class="el" href="main_8cpp.html">main.cpp</a></li>
<li>Yes, it's not only possible but also quite common to have multiple translation units in a single C++ project. You typically organize code into multiple source files to improve maintainability, encapsulation, and reusability. Here's a simple illustration of how you might organize a project:</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;lib.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">lib_function</a>(); <span class="comment">// Function from lib.cpp</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main function.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// lib.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;lib.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">lib_function</a>() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Function from lib.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// lib.h</span></div>
<div class="line"><span class="preprocessor">#ifndef LIB_H</span></div>
<div class="line"><span class="preprocessor">#define LIB_H</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">lib_function</a>(); <span class="comment">// Declaration of function from lib.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LIB_H</span></div>
<div class="ttc" id="a_c_make_c_x_x_compiler_id_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="_c_make_c_x_x_compiler_id_8cpp_source.html#l00830">CMakeCXXCompilerId.cpp:830</a></div></div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
</div><!-- fragment --><p>In this setup:</p>
<ul>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> includes <code>lib.h</code> to know about <code>lib_function()</code> and calls <code>lib_function()</code> within <code><a class="el" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a></code>.</li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> defines what <code>lib_function()</code> actually does.</li>
<li><code>lib.h</code> is the header file that declares <code>lib_function()</code>.</li>
</ul>
<p>Each <code>.cpp</code> file (<a class="el" href="main_8cpp.html">main.cpp</a> and <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a>) is a separate translation unit, and when you compile the project, each translation unit will be compiled into an object file:</p>
<ul>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> -&gt; <code>main.o</code></li>
<li><code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> -&gt; <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code></li>
</ul>
<p>Then, during the linking stage, both object files (<code>main.o</code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>) are linked together to form the final executable. You can compile and link these using a command-line interface with a compiler like g++. Here's how it might look:</p>
<div class="fragment"><div class="line">g++ -c main.cpp -o main.o</div>
<div class="line">g++ -c lib.cpp -o lib.o</div>
<div class="line">g++ main.o lib.o -o my_program</div>
</div><!-- fragment --><p>The <code>-c</code> flag tells the compiler to generate object files, and the final line without <code>-c</code> links the object files into an executable called <code>my_program</code>.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
Question -2</h2>
<ul>
<li>But I thought if I call lib in main then the result will be a one single big translation unit?<ul>
<li>It seems there might be a misunderstanding about how the translation unit works in relation to including one file within another. Including one file in another (such as <code>lib.h</code> in <code><a class="el" href="main_8cpp.html">main.cpp</a></code>) does not merge the contents of <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> into the translation unit of <code><a class="el" href="main_8cpp.html">main.cpp</a></code>.</li>
</ul>
</li>
</ul>
<p>Here's what happens when you include <code>lib.h</code> in <code><a class="el" href="main_8cpp.html">main.cpp</a></code>:</p>
<ol type="1">
<li><b>Preprocessing</b>: The content of <code>lib.h</code> is copied into <code><a class="el" href="main_8cpp.html">main.cpp</a></code> during the preprocessing step. This does not include the actual definitions and implementations of functions from <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code>—only their declarations from <code>lib.h</code>.</li>
<li><b>Compilation</b>: Each <code>.cpp</code> file is compiled separately into its own object file. <code><a class="el" href="main_8cpp.html">main.cpp</a></code> becomes <code>main.o</code>, and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> becomes <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>. At this point, <code>main.o</code> knows that <code>lib_function()</code> exists because it's declared in <code>lib.h</code>, but it doesn't know how it's implemented—that's in <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>.</li>
<li><b>Linking</b>: The linker then combines <code>main.o</code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code> into a single executable. The linker resolves the references to <code>lib_function()</code> in <code>main.o</code> by finding its definition in <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.o</a></code>.</li>
</ol>
<p>So, even though <code><a class="el" href="main_8cpp.html">main.cpp</a></code> includes <code>lib.h</code>, <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">lib.cpp</a></code> remain separate translation units. They are only brought together into a single, cohesive program during the linking stage, which is after each translation unit has been compiled into an object file.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Question -3</h2>
<p>Now, can I say in that case that for every CPP file there is a corresponding translation unit? If not then what is the reason? Is CPP file can be considered as a translation unit?</p>
<p>Yes, you can say that for every <code>.cpp</code> file, there is a corresponding translation unit in the context of compiling a C++ program. The <code>.cpp</code> file itself, along with all the content that gets included (<code>#include</code>) and expanded (macros, inline functions, templates, etc.) during the preprocessing step, forms a single translation unit. So, each <code>.cpp</code> file can indeed be considered a translation unit after preprocessing. Here's why:</p>
<ul>
<li><b>Preprocessing</b>: Each <code>.cpp</code> file is preprocessed individually. During this step, all included headers (<code>#include</code>), macros, and conditional compilation directives are processed. The result is a single, often much larger, source code file that is then ready for compilation. This preprocessed file represents the translation unit.</li>
<li><b>Compilation</b>: The translation unit is compiled into an object file. The compiler translates the preprocessed C++ code into assembly, which is then turned into machine code, producing an object file (<code>.o</code> or <code>.obj</code>).</li>
</ul>
<p>Therefore, the relationship is generally one-to-one: one <code>.cpp</code> file is preprocessed and compiled into one translation unit, which results in one object file. However, it's worth noting that a translation unit is a conceptual part of the compilation process and doesn't directly correspond to a physical file you can see (other than the <code>.cpp</code> source file and the resulting <code>.o</code> or <code>.obj</code> object file).</p>
<h2><a class="anchor" id="autotoc_md80"></a>
Question -4</h2>
<p>Is it possible to show the .i files after the pre processor Show me an easy hello world example using clang++ command line, and point what kind of flag is needed?</p>
<ul>
<li>The <code>.i</code> files are the result of the C preprocessor processing the source files (<code>.cpp</code>). They contain the expanded source code with all the macros replaced and header files included. Here's how you can see the <code>.i</code> preprocessed files using <code>clang++</code>.</li>
</ul>
<p>First, let's consider a simple "Hello, World!" program. You have two files: <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code>hello.h</code>.</p>
<p><code>hello.h</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef HELLO_H</span></div>
<div class="line"><span class="preprocessor">#define HELLO_H</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">say_hello</a>();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HELLO_H</span></div>
</div><!-- fragment --><p><code><a class="el" href="main_8cpp.html">main.cpp</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;hello.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">say_hello</a>() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">say_hello</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, to generate the <code>.i</code> preprocessed file using <code>clang++</code>, you would use the <code>-E</code> flag, which tells the compiler to stop after the preprocessing stage. Here's the command you would use in the terminal:</p>
<div class="fragment"><div class="line">clang++ -E main.cpp -o main.i</div>
</div><!-- fragment --><ul>
<li>This will create a <code>main.i</code> file which contains the result of preprocessing <code><a class="el" href="main_8cpp.html">main.cpp</a></code>. If you open <code>main.i</code>, you will see the contents of <code><a class="el" href="main_8cpp.html">main.cpp</a></code> with the contents of <code>hello.h</code> included inline and all preprocessing directives executed. It will also include the content from the standard library headers like <code>&lt;iostream&gt;</code> that were included in <code><a class="el" href="main_8cpp.html">main.cpp</a></code>.</li>
<li>The <code>.i</code> file is not typically used in the compilation process—it's mainly useful for debugging preprocessor issues. Normally, preprocessing is just the first step of the compilation that happens internally, and the compiler doesn't save the intermediate result unless specifically instructed to do so with flags like <code>-E</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
Question -5</h2>
<p>What is the result of main.i show it to me of your previous example?</p><ul>
<li>The <code>.i</code> file resulting from preprocessing <code><a class="el" href="main_8cpp.html">main.cpp</a></code> would contain the entire contents of <code><a class="el" href="main_8cpp.html">main.cpp</a></code> with all <code>#include</code> directives replaced by the actual content of the included files, macros expanded, and comments removed. This file can be quite large due to the inclusion of standard library headers like <code>&lt;iostream&gt;</code>.</li>
<li>For the simple <code><a class="el" href="main_8cpp.html">main.cpp</a></code> and <code>hello.h</code> files provided earlier, the <code>main.i</code> would look similar to the original <code><a class="el" href="main_8cpp.html">main.cpp</a></code>, but with the contents of <code>hello.h</code> copied into it and the expanded code from <code>&lt;iostream&gt;</code> and other headers included by it. Here is a simplified example of what the <code>main.i</code> might look like:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Contents of hello.h inlined (assuming hello.h does not include other headers)</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">say_hello</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...Lots of system-specific code from including &lt;iostream&gt;...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">say_hello</a>() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">say_hello</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...More system-specific code and definitions...</span></div>
</div><!-- fragment --><ul>
<li>The preprocessor output (<code>main.i</code>) would not normally be read by humans due to its size and complexity. However, it can be useful for debugging if you need to see exactly what the preprocessor is doing with your code.</li>
<li>The actual content can be thousands of lines long because standard headers like <code>&lt;iostream&gt;</code> often include other headers, which in turn include even more. It's a recursive and expansive inclusion of a large portion of the standard library. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
