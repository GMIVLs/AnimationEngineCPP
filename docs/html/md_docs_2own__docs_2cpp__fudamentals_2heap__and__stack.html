<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: Heap and Stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Heap and Stack</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md96"></a></p>
<ul>
<li>All methods to clean a heap memory</li>
<li>List all data structures in CPP allocated on heap vs on stack</li>
<li>Keyword New and allocations on the heap</li>
<li>Can I allocate on heap of multi dimensional array without using new keyword.</li>
<li>Can I allocate on heap primitive data</li>
</ul>
<h1><a class="anchor" id="autotoc_md97"></a>
All methods to clean a heap memory</h1>
<ul>
<li>Managing dynamically allocated memory (objects on the heap) is crucial in C++. Here's a table that outlines the different ways to deallocate or clean up heap-allocated objects:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Method</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Best Practices</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>delete</b>   </td><td class="markdownTableBodyNone">Used to deallocate memory that was allocated with <code>new</code> for single objects.   </td><td class="markdownTableBodyNone"><code>int* p = new int; delete p;</code>   </td><td class="markdownTableBodyNone">Always set the pointer to <code>nullptr</code> after <code>delete</code> to avoid dangling pointers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>delete[]</b>   </td><td class="markdownTableBodyNone">Used to deallocate memory that was allocated with <code>new[]</code> for arrays.   </td><td class="markdownTableBodyNone"><code>int* arr = new int[10]; delete[] arr;</code>   </td><td class="markdownTableBodyNone">Same as <code>delete</code>: always set the pointer to <code>nullptr</code> afterwards.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Destructor</b>   </td><td class="markdownTableBodyNone">A special class method that is invoked when an object goes out of scope or is explicitly deleted.   </td><td class="markdownTableBodyNone"><code>class MyClass { ~MyClass() { /* cleanup */ } };</code>   </td><td class="markdownTableBodyNone">Useful to release resources (like heap memory) associated with an object.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>std::unique_ptr</b>   </td><td class="markdownTableBodyNone">Smart pointer that owns a heap-allocated object and deletes it when the <code>unique_ptr</code> goes out of scope.   </td><td class="markdownTableBodyNone"><code>std::unique_ptr&lt;int&gt; <a class="el" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p(new int)</a>;</code>   </td><td class="markdownTableBodyNone">Avoids manual memory management. When the <code>unique_ptr</code> is destroyed, it automatically deletes the associated heap object.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>std::shared_ptr</b>   </td><td class="markdownTableBodyNone">Smart pointer that can have multiple owners. The heap object is deleted when the last <code>shared_ptr</code> is destroyed.   </td><td class="markdownTableBodyNone"><code>std::shared_ptr&lt;int&gt; p1(new int); std::shared_ptr&lt;int&gt; p2 = p1;</code>   </td><td class="markdownTableBodyNone">Reference counting ensures object is deleted only after last reference is gone. Prefer <code>std::make_shared</code> for allocation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>std::weak_ptr</b>   </td><td class="markdownTableBodyNone">A non-owning smart pointer. Doesn't affect the reference count of a <code>shared_ptr</code>.   </td><td class="markdownTableBodyNone"><code>std::weak_ptr&lt;int&gt; wp = p1;</code>   </td><td class="markdownTableBodyNone">Useful in situations where circular references might occur with <code>shared_ptr</code>. Doesn't prevent object from being deleted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Custom Deleter</b>   </td><td class="markdownTableBodyNone">Provide custom deletion logic for smart pointers.   </td><td class="markdownTableBodyNone"><code>auto deleter = [](int* p) { delete p; }; std::shared_ptr&lt;int&gt; <a class="el" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p(new int, deleter)</a>;</code>   </td><td class="markdownTableBodyNone">For special cleanup needs with smart pointers, like custom memory pools or specific deletion routines.   </td></tr>
</table>
<p><b>Important Points</b>:</p>
<ol type="1">
<li><b>Ownership</b>: With raw pointers, you need to manually manage ownership. With smart pointers, ownership semantics are clearer (<code>unique_ptr</code> has unique ownership, <code>shared_ptr</code> can have shared ownership).</li>
<li><b>Dangling Pointers</b>: After deallocating memory using <code>delete</code> or <code>delete[]</code>, always set the pointer to <code>nullptr</code> to prevent accidental access to now-deallocated memory.</li>
<li><b>Avoid Manual Management</b>: Whenever possible, prefer to use smart pointers like <code>std::unique_ptr</code> and <code>std::shared_ptr</code> over raw pointers. They provide automatic memory management, making the code safer against memory leaks and other memory-related issues.</li>
<li><b>Custom Deleters</b>: They allow you to provide specific logic for deallocating memory or resources when using smart pointers. Useful in scenarios where the default <code>delete</code> isn't suitable.</li>
</ol>
<ul>
<li>To utilize smart pointers, remember to include the <code>&lt;memory&gt;</code> header.</li>
</ul>
<h1><a class="anchor" id="autotoc_md98"></a>
List all data structures in CPP allocated on heap vs on stack</h1>
<p>In C++, you have control over whether you want to allocate memory on the stack or on the heap. This applies to almost any type of data structure, including both built-in types (like <code>int</code>, <code>double</code>, <code>array</code>, etc.) and user-defined types (like classes and structs).</p>
<p>Here's a list of some common data structures in C++, and examples of how you could allocate them on the stack or on the heap:</p>
<ol type="1">
<li><b>Arrays</b>:<ul>
<li>Stack: <code>int arr[10];</code></li>
<li>Heap: <code>int* arr = new int[10];</code></li>
</ul>
</li>
<li><b>Standard Library Containers (like <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, etc.)</b>:<ul>
<li>Stack: <code>std::vector&lt;int&gt; vec(10);</code></li>
<li>Heap: <code>std::vector&lt;int&gt;* vec = new std::vector&lt;int&gt;(10);</code></li>
</ul>
</li>
<li><b>Classes/Structs</b>:<ul>
<li>Stack: <code>MyClass obj;</code></li>
<li>Heap: <code>MyClass* obj = new MyClass();</code></li>
</ul>
</li>
<li><b>Strings</b>:<ul>
<li>Stack: <code>std::string str;</code></li>
<li>Heap: <code>std::string* str = new std::string();</code></li>
</ul>
</li>
</ol>
<p>Note that when you allocate memory on the heap (using <code>new</code>), it's your responsibility to deallocate it when you're done using it (using <code>delete</code>). If you forget to do this, it can lead to memory leaks.</p>
<p>On the other hand, when you allocate memory on the stack, it automatically gets deallocated when it goes out of scope. This makes memory management easier, but it also means that stack-allocated memory can't be used to persist data beyond the lifetime of the current scope.</p>
<p>Remember that <code>std::vector</code> and other Standard Library containers automatically manage their own memory, so even when you allocate them on the stack, they can still hold large amounts of data that's actually stored on the heap. So, you get the convenience of stack allocation (automatic lifetime management) with the flexibility of heap allocation (dynamic size).</p>
<p>Finally, note that some types, like <code>std::array</code>, are intended to be allocated on the stack, and don't have a straightforward way to be allocated on the heap. Conversely, things like <code>std::shared_ptr</code> or <code>std::unique_ptr</code> are designed to manage heap-allocated memory.</p>
<h1><a class="anchor" id="autotoc_md99"></a>
Keyword New and allocations on the heap</h1>
<p>In C++, there are two common ways to allocate memory on the heap:</p>
<ol type="1">
<li><b>new</b>: This is the most common way. It allocates memory and calls the constructor for the object.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* i = <span class="keyword">new</span> int(5); <span class="comment">// allocate an int on the heap with a value of 5</span></div>
</div><!-- fragment --><ol type="1">
<li><b>malloc</b>: This is a C library function also available in C++. It allocates a block of memory of the specified size and returns a pointer to it, but does not call the constructor.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* i = (<span class="keywordtype">int</span>*)<a class="code hl_class" href="class_vector__2d.html">malloc</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)); <span class="comment">// allocate an int on the heap, not initialized</span></div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
</div><!-- fragment --><p>In modern C++, it's recommended to use <code>new</code> over <code>malloc</code>, as <code>new</code> is type-safe, calls constructors, and is more flexible with C++ types.</p>
<p>In addition to <code>new</code>, in modern C++, you could use smart pointers like <code>std::unique_ptr</code> or <code>std::shared_ptr</code>, which automatically manage memory deallocation, reducing the risk of memory leaks.</p>
<p>For example:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;int&gt; i(<span class="keyword">new</span> <span class="keywordtype">int</span>(5));  <span class="comment">// Using new</span></div>
<div class="line"><span class="comment">// or even better:</span></div>
<div class="line"><span class="keyword">auto</span> i = std::make_unique&lt;int&gt;(5);   <span class="comment">// Using std::make_unique</span></div>
</div><!-- fragment --><p>In this case, <code>i</code> will automatically be deallocated when it goes out of scope. This makes your code safer and easier to maintain by reducing manual memory management.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Can I allocate on heap of multi dimensional array without using new keyword.</h1>
<p>In C++, the <code>new</code> keyword is typically used to allocate memory on the heap. However, there are other ways to allocate memory on the heap that don't directly involve <code>new</code>. One alternative is to use <code>malloc()</code>, <code>calloc()</code>, and <code>realloc()</code>, which are part of the C standard library (included via <code>#include &lt;cstdlib&gt;</code> or <code>#include &lt;stdlib.h&gt;</code> in C++). These functions allow you to allocate and deallocate memory on the heap. Here's an example of how you could use <code>malloc()</code> to allocate a 2D array on the heap:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">rows</a> = 5;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">cols</a> = 10;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Allocate memory for the rows</span></div>
<div class="line">    <span class="keywordtype">int</span>** <a class="code hl_class" href="class_vector__2d.html">arr</a> = (<span class="keywordtype">int</span>**)<a class="code hl_class" href="class_vector__2d.html">malloc</a>(<a class="code hl_class" href="class_vector__2d.html">rows</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For each row, allocate memory for the columns</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_class" href="class_vector__2d.html">rows</a>; i++) {</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">arr</a>[i] = (<span class="keywordtype">int</span>*)<a class="code hl_class" href="class_vector__2d.html">malloc</a>(<a class="code hl_class" href="class_vector__2d.html">cols</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Don&#39;t forget to free the memory!</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_class" href="class_vector__2d.html">rows</a>; i++) {</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">free</a>(<a class="code hl_class" href="class_vector__2d.html">arr</a>[i]);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">free</a>(<a class="code hl_class" href="class_vector__2d.html">arr</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_c_make_c_x_x_compiler_id_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="_c_make_c_x_x_compiler_id_8cpp_source.html#l00830">CMakeCXXCompilerId.cpp:830</a></div></div>
</div><!-- fragment --><p>Please note that while <code>malloc</code> and its associated functions are available in C++, they're considered more C-style and their usage is generally discouraged in C++ where <code>new</code> and <code>delete</code> (or smart pointers) are preferred. They do not call constructors and destructors, which makes them unsuitable for non-trivial types. If you don't want to use <code>new</code> directly, but want the benefits it provides (like constructors and destructors being automatically called), you can use <code>std::vector</code> or other similar containers, which handle memory management for you:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">rows</a> = 5;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">cols</a> = 10;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a 2D vector (a vector of vectors)</span></div>
<div class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; <a class="code hl_class" href="class_vector__2d.html">vec</a>(<a class="code hl_class" href="class_vector__2d.html">rows</a>, std::vector&lt;int&gt;(<a class="code hl_class" href="class_vector__2d.html">cols</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You don&#39;t need to worry about freeing the memory</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This creates a 2D array (in the form of a <code>std::vector</code>) on the heap. When <code>vec</code> goes out of scope, its destructor is called, which automatically frees the memory it was using. This helps prevent memory leaks, which can be a common issue when manually managing memory.</p>
<h1><a class="anchor" id="autotoc_md101"></a>
Can I allocate on heap primitive data</h1>
<p>Yes, you can create primitive types on the heap in C++. However, the syntax you provided is incorrect. The correct way to do it is to use the <code>new</code> keyword followed by the type, and then assign this to a pointer. Here's how you can do it:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">var</a> = 10;  <span class="comment">// This creates an integer on the stack.</span></div>
<div class="line"><span class="keywordtype">int</span>* <a class="code hl_class" href="class_vector__2d.html">var_on_heap</a> = <span class="keyword">new</span> int(<a class="code hl_class" href="class_vector__2d.html">var</a>);  <span class="comment">// This creates an integer on the heap, with the value of var.</span></div>
</div><!-- fragment --><p>In this code:</p>
<ol type="1">
<li><code>var</code> is an integer variable that is allocated on the stack and initialized with the value <code>10</code>.</li>
<li><code>var_on_heap</code> is a pointer to an integer that is allocated on the heap. The <code>new</code> keyword is used to allocate memory on the heap, and the <code>int(var)</code> syntax initializes the heap-allocated integer with the value of <code>var</code>.</li>
</ol>
<p>Remember, when you allocate memory on the heap using <code>new</code>, you should deallocate it using <code>delete</code> to prevent memory leaks:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">delete</span> <a class="code hl_class" href="class_vector__2d.html">var_on_heap</a>;  <span class="comment">// This deallocates the memory on the heap.</span></div>
</div><!-- fragment --><p>After calling <code>delete</code>, the memory that <code>var_on_heap</code> points to is deallocated, but <code>var_on_heap</code> itself still exists and now is a dangling pointer. It's a good practice to set <code>var_on_heap</code> to <code>nullptr</code> after deleting it to prevent any future misuse:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">var_on_heap</a> = <span class="keyword">nullptr</span>;  <span class="comment">// This sets var_on_heap to the null pointer.</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
