<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: How to create a matrix on stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">How to create a matrix on stack</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md127"></a></p>
<ul>
<li>All matrix elements combination</li>
<li>Matrix multiplication and matrix element wise operations</li>
<li>List libraries to deal with linear algebra and vectors, matrices in cpp</li>
<li>How about optimization libraries that has algorithms to maximize the likelihood for login model for example ?</li>
<li>Request</li>
<li>A basic implementation of Linear Regression using Eigen.</li>
<li>Maximum Likelihood Estimation</li>
<li>Optimization Techniques to Estimate The Maximum Likelihood Parameters</li>
</ul>
<p>In C++, you can create a matrix (2D array) on the stack using fixed sizes. Here's an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <span class="comment">// Create a 3x3 matrix</span></div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[3][3] = {</div>
<div class="line">        {1, 2, 3},</div>
<div class="line">        {4, 5, 6},</div>
<div class="line">        {7, 8, 9}</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the matrix</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; 3; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">            std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_c_make_c_x_x_compiler_id_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="_c_make_c_x_x_compiler_id_8cpp_source.html#l00830">CMakeCXXCompilerId.cpp:830</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a7b24a3f2f56eb1244ae69dacb4fecb6f"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a></div><div class="ttdeci">GLuint GLenum matrix</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l12040">SDL_opengl_glext.h:12040</a></div></div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
</div><!-- fragment --><p>This will print:</p>
<div class="fragment"><div class="line">1 2 3</div>
<div class="line">4 5 6</div>
<div class="line">7 8 9</div>
</div><!-- fragment --><p>This approach works for small fixed-size matrices. If you're not sure about the size at compile time, or if the matrix can be large, you may consider using the heap or utilizing data structures like <code>std::vector</code> for dynamic sizing.</p>
<h1><a class="anchor" id="autotoc_md128"></a>
All matrix elements combination</h1>
<p>Like diagonal, lower tringle, upper triangle, off diagonal and all other variations dont skip anything</p>
<p>Certainly! Let's go through each of the combinations of matrix elements you mentioned:</p>
<p>Assuming we have an (n \times n) matrix named <code>matrix</code>:</p>
<ol type="1">
<li><p class="startli"><b>Main Diagonal</b>: Elements for which row index is equal to column index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ac0a41baf8b02de6cb4211d7f15f4872e"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a></div><div class="ttdeci">GLdouble n</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02226">SDL_opengl_glext.h:2226</a></div></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Secondary Diagonal</b> (or anti-diagonal): Elements for which row index and column index sum up to (n-1).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> - i - 1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Upper Triangle</b>: Elements for which row index is less than column index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = i + 1; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Lower Triangle</b>: Elements for which row index is greater than column index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; i; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Off Diagonal</b>: Every element that is not on the main diagonal.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        <span class="keywordflow">if</span> (i != <a class="code hl_class" href="class_vector__2d.html">j</a>) {</div>
<div class="line">            std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Strict Upper Triangle</b>: Upper triangle excluding the main diagonal.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = i + 1; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Strict Lower Triangle</b>: Lower triangle excluding the main diagonal. <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; i; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b24a3f2f56eb1244ae69dacb4fecb6f">matrix</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<p>All the above combinations are for square matrices (where number of rows equals number of columns). Some of these terms might differ slightly depending on context or literature, but these are the general definitions and implementations in C++.</p>
<h1><a class="anchor" id="autotoc_md129"></a>
Matrix multiplication and matrix element wise operations</h1>
<p>Sure, let's walk through matrix multiplication and element-wise operations:</p>
<ol type="1">
<li><b>Matrix Multiplication</b>: For two matrices <code>A</code> and <code>B</code> to be multiplied, the number of columns in <code>A</code> must be equal to the number of rows in <code>B</code>. The result of the multiplication is a matrix <code>C</code> with the number of rows of <code>A</code> and the number of columns of <code>B</code>.</li>
</ol>
<p>For matrices: <code>A</code> of dimension (m \times n) <code>B</code> of dimension (n \times p) The resultant matrix <code>C</code> will be of dimension (m \times p).</p>
<div class="fragment"><div class="line"><span class="comment">// Assuming A is of dimension m x n and B is of dimension n x p</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">C</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">k</a> = 0; <a class="code hl_class" href="class_vector__2d.html">k</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; <a class="code hl_class" href="class_vector__2d.html">k</a>++) {</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">C</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] += <a class="code hl_class" href="class_vector__2d.html">A</a>[i][<a class="code hl_class" href="class_vector__2d.html">k</a>] * <a class="code hl_class" href="class_vector__2d.html">B</a>[<a class="code hl_class" href="class_vector__2d.html">k</a>][<a class="code hl_class" href="class_vector__2d.html">j</a>];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_aa5367c14d90f462230c2611b81b41d23"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a></div><div class="ttdeci">GLfloat GLfloat p</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l13126">SDL_opengl_glext.h:13126</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_af593500c283bf1a787a6f947f503a5c2"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a></div><div class="ttdeci">const GLfloat * m</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l07099">SDL_opengl_glext.h:7099</a></div></div>
</div><!-- fragment --><ol type="1">
<li><b>Element-wise Operations</b>:<ul>
<li><p class="startli"><b>Addition</b>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a>; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">C</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] = <a class="code hl_class" href="class_vector__2d.html">A</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>] + <a class="code hl_class" href="class_vector__2d.html">B</a>[i][<a class="code hl_class" href="class_vector__2d.html">j</a>];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Subtraction</b>:</p>
<p class="startli"><code>cpp for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { C[i][j] = A[i][j] - B[i][j]; } } </code></p>
</li>
<li><p class="startli"><b>Multiplication</b> (Element-wise/Hadamard product):</p>
<p class="startli"><code>cpp for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { C[i][j] = A[i][j] * B[i][j]; } } </code></p>
</li>
<li><b>Division</b>: <code>cpp for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { C[i][j] = A[i][j] / B[i][j]; // Make sure to handle the case when B[i][j] = 0 } } </code></li>
</ul>
</li>
</ol>
<p>For the element-wise operations, matrices <code>A</code> and <code>B</code> should have the same dimensions (both (m \times n)), otherwise the operations are not defined. The resultant matrix <code>C</code> will also be of the same dimension (m \times n).</p>
<p>Note: Error handling (like checking for matrix dimensions compatibility) is omitted for simplicity. In a real-world application, you would need to add those checks before performing these operations.</p>
<h1><a class="anchor" id="autotoc_md130"></a>
List libraries to deal with linear algebra and vectors, matrices in cpp</h1>
<p>Here is a list of some popular C++ libraries used for dealing with linear algebra, vectors, and matrices:</p>
<ol type="1">
<li><b>Eigen</b>: This is probably one of the most widely used C++ libraries for linear algebra. It provides various operations for manipulating matrices, vectors, and numerical solvers. It is both high-performance and easy to use.</li>
<li><b>Armadillo</b>: Armadillo is a high-quality C++ linear algebra library, aiming towards a good balance between speed and ease of use. The syntax is deliberately similar to Matlab.</li>
<li><b>BLAS (Basic Linear Algebra Subprograms)</b>: This is a standard library that provides efficient operations for many kinds of vector and matrix operations. Although it's a low-level library and may be more complex to use, it is very fast due to hardware optimizations.</li>
<li><b>LAPACK (Linear Algebra PACKage)</b>: This is a standard library for performing more advanced linear algebra operations, such as decompositions and eigenvalue calculations. LAPACK interfaces well with BLAS for efficient computations.</li>
<li><b>Boost uBLAS</b>: This is part of the larger Boost library collection. It provides classes for vectors and matrices and operations for linear algebra.</li>
<li><b>GSL (GNU Scientific Library)</b>: It provides a wide range of mathematical routines such as random number generators, special functions, and least-squares fitting. It has a CBLAS interface which provides basic routines for vector and matrix operations.</li>
<li><b>GLM (OpenGL Mathematics)</b>: This is a header only C++ mathematics library for graphics software based on the OpenGL Shading Language (GLSL) specifications. It's commonly used in computer graphics tasks.</li>
</ol>
<p>Remember to choose the library that best fits your needs and requirements. Some are easier to use and have more features, while others are more minimal but may offer better performance.</p>
<h1><a class="anchor" id="autotoc_md131"></a>
How about optimization libraries that has algorithms to maximize the likelihood for login model for example ?</h1>
<p>There are several libraries in C++ that can help you with optimization tasks such as maximizing the likelihood for a logistic model:</p>
<ol type="1">
<li><b>NLopt</b>: NLopt is a library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms. It provides capabilities for global optimization, local optimization, and constrained optimization.</li>
<li><b>Ceres Solver</b>: Ceres Solver is an open-source C++ library for modeling and solving large, complicated optimization problems. It can be used to solve Non-linear Least Squares problems with bounds constraints and general unconstrained optimization problems.</li>
<li><b>Optimization with Ipopt and CppAD</b>: Ipopt (Interior Point OPTimizer) is a software package for large-scale nonlinear optimization. CppAD is a C++ library that computes derivatives. Together they provide a powerful tool for optimization.</li>
<li><b>Dlib</b>: Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real-world problems. It provides a number of optimization algorithms, including for numerical optimization.</li>
<li><b>GSL - GNU Scientific Library</b>: The library provides a broad set of mathematical routines such as random number generators, special functions, and least-squares fitting. The multi-dimensional minimization algorithms might be helpful for your purpose.</li>
</ol>
<p>The choice of library depends heavily on the specifics of your problem and your specific use case.</p>
<h1><a class="anchor" id="autotoc_md132"></a>
Request</h1>
<p>Give me linear regression class that has optimization for estimating the parameters assume computing the parameters numerically don’t use other libraries use only CPP standard The estimation should has option either compute using least square method or using maximum likelihood method, both cases should the derivative computed numerically</p>
<ul>
<li>Implementing numerical methods for optimization, such as gradient descent, from scratch requires careful consideration due to the numerous pitfalls of numerical computation. Here's a very basic and rough implementation of a Linear Regression class using least squares and gradient descent for Maximum Likelihood Estimation. Please note that these implementations are very rudimentary and should be enhanced for robustness and performance before use in any kind of production or research code.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">LinearRegression</a> {</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">slope</a>;</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">intercept</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Estimate parameters using least squares method</span></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">least_squares</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>) {</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">x_mean</a> = std::accumulate(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>.begin(), <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>.end(), 0.0) / <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>.size();</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">y_mean</a> = std::accumulate(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>.begin(), <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>.end(), 0.0) / <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>.size();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a> = 0.0;</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">den</a> = 0.0;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>.size(); i++) {</div>
<div class="line">            <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a> += (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[i] - <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">x_mean</a>) * (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>[i] - <a class="code hl_class" href="class_vector__2d.html">y_mean</a>);</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">den</a> += (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[i] - <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">x_mean</a>) * (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[i] - <a class="code hl_class" href="class_vector__2d.html">x_mean</a>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">slope</a> = <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a> / <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">den</a>;</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">intercept</a> = <a class="code hl_class" href="class_vector__2d.html">y_mean</a> - <a class="code hl_class" href="class_vector__2d.html">slope</a> * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">x_mean</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Estimate parameters using gradient descent (Maximum Likelihood Estimation)</span></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">gradient_descent</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>, <span class="keywordtype">double</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac03904b1f7e359bb2acf10a755e97c5a">alpha</a> = 0.01, <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">iterations</a> = 1000) {</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">slope</a> = 0.0;</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">intercept</a> = 0.0;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">iterations</a>; i++) {</div>
<div class="line">            <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">slope_grad</a> = 0.0;</div>
<div class="line">            <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">intercept_grad</a> = 0.0;</div>
<div class="line">            <span class="keywordtype">double</span> <a class="code hl_class" href="class_vector__2d.html">N</a> = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>.size();</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> <a class="code hl_class" href="class_vector__2d.html">j</a> = 0; <a class="code hl_class" href="class_vector__2d.html">j</a> &lt; <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">N</a>; <a class="code hl_class" href="class_vector__2d.html">j</a>++) {</div>
<div class="line">                <a class="code hl_class" href="class_vector__2d.html">slope_grad</a> += -(2/<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">N</a>) * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[<a class="code hl_class" href="class_vector__2d.html">j</a>] * (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>[<a class="code hl_class" href="class_vector__2d.html">j</a>] - (<a class="code hl_class" href="class_vector__2d.html">slope</a> * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[<a class="code hl_class" href="class_vector__2d.html">j</a>] + <a class="code hl_class" href="class_vector__2d.html">intercept</a>));</div>
<div class="line">                <a class="code hl_class" href="class_vector__2d.html">intercept_grad</a> += -(2/<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">N</a>) * (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>[<a class="code hl_class" href="class_vector__2d.html">j</a>] - (<a class="code hl_class" href="class_vector__2d.html">slope</a> * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[<a class="code hl_class" href="class_vector__2d.html">j</a>] + <a class="code hl_class" href="class_vector__2d.html">intercept</a>));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">slope</a> = <a class="code hl_class" href="class_vector__2d.html">slope</a> - <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac03904b1f7e359bb2acf10a755e97c5a">alpha</a> * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">slope_grad</a>;</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">intercept</a> = <a class="code hl_class" href="class_vector__2d.html">intercept</a> - <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac03904b1f7e359bb2acf10a755e97c5a">alpha</a> * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">intercept_grad</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make prediction</span></div>
<div class="line">    <span class="keywordtype">double</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">predict</a>(<span class="keywordtype">double</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">slope</a> * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> + <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">intercept</a>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a1675d9d7bb68e1657ff028643b4037e3"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a></div><div class="ttdeci">GLint GLint GLint GLint GLint GLint y</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01574">SDL_opengl.h:1574</a></div></div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_abe1577120f1766eff913e9a74879f373"><div class="ttname"><a href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a></div><div class="ttdeci">GLint GLint GLint GLint GLint x</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01574">SDL_opengl.h:1574</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_abb50fc1ead3a02a46fb52daa2045f95c"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a></div><div class="ttdeci">GLuint num</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l05929">SDL_opengl_glext.h:5929</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ac03904b1f7e359bb2acf10a755e97c5a"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ac03904b1f7e359bb2acf10a755e97c5a">alpha</a></div><div class="ttdeci">GLfloat GLfloat GLfloat alpha</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00710">SDL_opengl_glext.h:710</a></div></div>
<div class="ttc" id="aclass_vector__2d_html_a6d09fb691e01f179efcbef03bef13b9c"><div class="ttname"><a href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Vector_2d::Vector_2d</a></div><div class="ttdeci">Vector_2d()</div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8cpp_source.html#l00018">Vector_2d.cpp:18</a></div></div>
</div><!-- fragment --><ul>
<li>The <code>least_squares</code> method implements the analytical solution to the least squares problem for linear regression, while the <code>gradient_descent</code> method implements a basic gradient descent algorithm for Maximum Likelihood Estimation (assuming normally distributed errors).</li>
<li>These methods will set the slope and intercept parameters of the class, which can then be used to make predictions with the <code>predict</code> method.</li>
<li>Note that this code does not include any error checking or handling, and the gradient descent method may not converge if the learning rate (<code>alpha</code>) is not properly set or the number of iterations is insufficient. The performance of this gradient descent implementation will also not be very good on large datasets, as it uses a simple loop to compute the gradient at each step. For larger datasets, a more efficient implementation would be required, possibly involving parallel computation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md133"></a>
A basic implementation of Linear Regression using Eigen.</h1>
<p>Note that this is a rudimentary implementation that doesn't include features such as regularization or interaction terms, but it should give you a starting point for your own work.</p>
<p>This code doesn't include the maximization of the likelihood function for MLE, as this is a bit more complex and depends heavily on the specificities of your problem.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">LinearRegression</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">LinearRegression</a>() {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">train</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> &amp;<a class="code hl_class" href="class_vector__2d.html">X</a>, <span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Add a column of ones for the bias term</span></div>
<div class="line">        <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> <a class="code hl_class" href="class_vector__2d.html">Xb</a> = Eigen::MatrixXd::Ones(<a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols() + 1);</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">Xb</a>.block(0, 1, <a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols()) = <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">X</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the weights using the normal equation</span></div>
<div class="line">        <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a3fc6a10c8f7ffa12a6a7855d06ff581d">weights</a> = (<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Xb</a>).<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">ldlt</a>().solve(<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">predict</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> &amp;<a class="code hl_class" href="class_vector__2d.html">X</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Add a column of ones for the bias term</span></div>
<div class="line">        <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> <a class="code hl_class" href="class_vector__2d.html">Xb</a> = Eigen::MatrixXd::Ones(<a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols() + 1);</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">Xb</a>.block(0, 1, <a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols()) = <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">X</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">Xb</a> * <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a3fc6a10c8f7ffa12a6a7855d06ff581d">weights</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a3fc6a10c8f7ffa12a6a7855d06ff581d">weights</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a simple dataset</span></div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> <a class="code hl_class" href="class_vector__2d.html">X</a>(100, 1);</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">X</a> &lt;&lt; Eigen::VectorXd::Random(100);</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = 2.0 * <a class="code hl_class" href="class_vector__2d.html">X</a>.array() + 0.5 + Eigen::VectorXd::Random(100) / 10;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Train the model</span></div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">LinearRegression</a> <a class="code hl_class" href="class_vector__2d.html">model</a>;</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">model</a>.train(<a class="code hl_class" href="class_vector__2d.html">X</a>, <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Predict the output for the training data</span></div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_class" href="class_vector__2d.html">y_pred</a> = <a class="code hl_class" href="class_vector__2d.html">model</a>.predict(<a class="code hl_class" href="class_vector__2d.html">X</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the first 10 predictions</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">y_pred</a>.head(10) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a3fc6a10c8f7ffa12a6a7855d06ff581d"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a3fc6a10c8f7ffa12a6a7855d06ff581d">weights</a></div><div class="ttdeci">const GLbyte * weights</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l04969">SDL_opengl_glext.h:4969</a></div></div>
</div><!-- fragment --><ul>
<li>This code first prepares the feature matrix X by adding a column of ones. This is done because the bias term (often called "intercept") in linear regression can be included as an extra feature that is always set to one. The weights are then computed using the normal equation, which is a simple and efficient way to find the least squares solution for linear regression.</li>
<li>To implement linear regression with MLE, you will need to set up the likelihood function for the Gaussian distribution (which is the usual assumption for the error term in linear regression), and then use an optimization algorithm to find the parameters that maximize this function. This is more involved and requires the use of a nonlinear optimization library.</li>
<li>Please note that to run this program, you need to link the Eigen library. If you're using CMake, add find_package(Eigen3 REQUIRED) in your <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">CMakeLists.txt</a> file and link it with target_link_libraries(your_target Eigen3::Eigen).</li>
</ul>
<h1><a class="anchor" id="autotoc_md134"></a>
Maximum Likelihood Estimation</h1>
<p>Maximum likelihood estimation (MLE) in linear regression is a bit more complicated than the least squares method because it involves an optimization problem. You would typically use an optimization library to solve it.</p>
<ul>
<li>A key thing to understand about MLE in linear regression is that if the errors are normally distributed, then the maximum likelihood estimates for the regression coefficients are the same as the least squares estimates.</li>
<li>That said, here's a basic example of a linear regression class where we use MLE for estimation assuming a normal distribution of errors. For simplicity, we will use the numerical optimization method provided by Eigen, Newton's method:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">LinearRegressionMLE</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">LinearRegressionMLE</a>() {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">train</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> &amp;<a class="code hl_class" href="class_vector__2d.html">X</a>, <span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Add a column of ones for the bias term</span></div>
<div class="line">        <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> <a class="code hl_class" href="class_vector__2d.html">Xb</a> = Eigen::MatrixXd::Ones(<a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols() + 1);</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">Xb</a>.block(0, 1, <a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols()) = <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">X</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// initialize coefficients with Least Squares Estimation</span></div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">coefficients</a> = (<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Xb</a>).<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">ldlt</a>().solve(<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// use newton&#39;s method to find coefficients that maximize log-likelihood</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) <span class="comment">// arbitrary number of steps</span></div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a> = <a class="code hl_class" href="class_vector__2d.html">Xb</a> * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">coefficients</a>;</div>
<div class="line">            <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a> = 1 / (1 + (-<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a>.array()).<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">exp</a>()); <span class="comment">// logistic function</span></div>
<div class="line">            <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a> = <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>.array() * (1 - <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>.array());</div>
<div class="line">            <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1c599441d9dece861ee2cd70e31ce120">z</a> = <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a> + (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> - <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>).<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a52f38e7d822a46377fde7a02708eedb1">array</a>() / <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a>.array();</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">coefficients</a> = (<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a>.asDiagonal() * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Xb</a>).<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">ldlt</a>().solve(<a class="code hl_class" href="class_vector__2d.html">Xb</a>.transpose() * <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a>.asDiagonal() * <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1c599441d9dece861ee2cd70e31ce120">z</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">predict</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> &amp;<a class="code hl_class" href="class_vector__2d.html">X</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Add a column of ones for the bias term</span></div>
<div class="line">        <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::MatrixXd</a> <a class="code hl_class" href="class_vector__2d.html">Xb</a> = Eigen::MatrixXd::Ones(<a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols() + 1);</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">Xb</a>.block(0, 1, <a class="code hl_class" href="class_vector__2d.html">X</a>.rows(), <a class="code hl_class" href="class_vector__2d.html">X</a>.cols()) = <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">X</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">Xb</a> * <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">coefficients</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Eigen::VectorXd</a> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">coefficients</a>;</div>
<div class="line">};</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a1c599441d9dece861ee2cd70e31ce120"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a1c599441d9dece861ee2cd70e31ce120">z</a></div><div class="ttdeci">GLdouble GLdouble z</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00702">SDL_opengl_glext.h:702</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a52f38e7d822a46377fde7a02708eedb1"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a52f38e7d822a46377fde7a02708eedb1">array</a></div><div class="ttdeci">GLenum array</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l07307">SDL_opengl_glext.h:7307</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_afa0fb1b5e976920c0abeff2dca3ed774"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a></div><div class="ttdeci">GLfloat GLfloat GLfloat GLfloat h</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02220">SDL_opengl_glext.h:2220</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_afb1b07e1b25035d41d60fb2c03d507e6"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a></div><div class="ttdeci">GLubyte GLubyte GLubyte GLubyte w</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l01023">SDL_opengl_glext.h:1023</a></div></div>
</div><!-- fragment --><p>This example sets up a logistic regression problem and uses Newton's method to find the maximum likelihood estimate of the parameters. Please note that this implementation is a simplification and doesn't include many things that you would typically want in a machine learning algorithm, such as regularization, error checking, or a stopping criterion for the optimization process. It is provided as a simple starting point for your own work.</p>
<h1><a class="anchor" id="autotoc_md135"></a>
Optimization Techniques to Estimate The Maximum Likelihood Parameters</h1>
<p>There are several optimization techniques that can be used to estimate the parameters in a maximum likelihood model. These techniques are designed to find the parameters that maximize the likelihood function, often iteratively improving the estimates. Here are a few key methods:</p>
<ol type="1">
<li><b>Gradient Descent:</b> This is a first-order iterative optimization algorithm for finding the minimum of a function. In the context of maximum likelihood estimation (MLE), we would find the maximum by using the negative of the function (or equivalently, minimize the negative log-likelihood). It is based on the observation that if a multivariable function is defined and differentiable in a neighborhood of a point, then the function decreases fastest if one goes in the direction of the negative gradient.</li>
<li><b>Stochastic Gradient Descent (SGD):</b> It's a version of gradient descent, but instead of calculating the gradient on the entire dataset, it estimates the gradient on a subset (batch) of data. SGD is useful when dealing with large datasets.</li>
<li><b>Newton's Method (also called the Newton-Raphson method):</b> This method uses the second-order Taylor series expansion to approximate the objective function, leading to faster convergence compared to gradient descent. However, this requires calculation of the second derivative (Hessian matrix), which can be computationally intensive for high-dimensional data.</li>
<li><b>Quasi-Newton Methods (BFGS, L-BFGS):</b> These methods also approximate the objective function using the second-order Taylor series expansion, but they update an estimate of the Hessian matrix iteratively, which is less computationally intensive than directly calculating the Hessian matrix.</li>
<li><b>Expectation-Maximization (EM) Algorithm:</b> This is particularly useful when the model depends on some hidden or latent variables. The EM algorithm iteratively performs an expectation (E) step, which creates a function for the expectation of the log-likelihood evaluated using the current estimate for the parameters, and a maximization (M) step, which computes parameters maximizing the expected log-likelihood found on the E step.</li>
<li><b>Conjugate Gradient Method:</b> This is an algorithm for the numerical solution of particular systems of linear equations, namely those whose matrix is symmetric and positive-definite. The conjugate gradient method is often implemented as an iterative algorithm, applicable to sparse systems that are too large to be handled by a direct implementation or other direct methods such as the Cholesky decomposition.</li>
</ol>
<p>It should be noted that the best method to use for a given problem depends on many factors, including the structure of the likelihood function, the number of parameters, the size of the dataset, and the specifics of the computing environment. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
