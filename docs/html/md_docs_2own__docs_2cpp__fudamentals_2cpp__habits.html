<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: Habits You Need to Ditch in C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Habits You Need to Ditch in C++</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md60"></a></p>
<ul>
<li>**Introduction**</li>
<li>_REFERENCES_</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md62"></a>
&lt;strong&gt;Introduction&lt;/strong&gt;</h1>
<p>Welcome to the list of newbie C++ habits, C++ is an incredibly complex language with a lot of history, so whether you need to get actual programming with you really needs to look out for these things or whether you just want to improve your code a little bit, **_let's get <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">started._</a>**</p>
<ol type="1">
<li>Using Namespace std, people generally use it to save typing like <b>cout</b> instead of <b>std::cout</b> or <b>string</b> instead of <b>std::string</b>. If it's limited to just a single function that might not be that bad but, let's be honest it's usually used at the global level even worse, if you do this in a header file then you also force this choice upon every one uses your code.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Please don't do this in a header file. Consider just using the names that you, actually use. <strike>using namespace std;</strike> </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a> , <span class="keywordtype">char</span> ** argv){</div>
<div class="line">    <span class="keywordtype">string</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a> {<span class="stringliteral">&quot;Hello World...!&quot;</span>};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">cout</a> &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_c_make_c_x_x_compiler_id_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="_c_make_c_x_x_compiler_id_8cpp_source.html#l00830">CMakeCXXCompilerId.cpp:830</a></div></div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a4af680a6c683f88ed67b76f207f2e6e4"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a></div><div class="ttdeci">GLdouble s</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l02063">SDL_opengl.h:2063</a></div></div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> <a href="stl__logging_8h_source.html#l00218">stl_logging.h:218</a></div></div>
</div><!-- fragment --><p>**_instead use like:_**</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>std::cout, std::string, std::endl;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a> , <span class="keywordtype">char</span> ** argv){</div>
<div class="line">    <span class="keywordtype">string</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>{<span class="stringliteral">&quot;Hello World...!&quot;</span>};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">cout</a> &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Using <b>std::endl</b> , especially in a loop you probably meant to just print out a new line but, <b>endl</b> dose more than that it also flushes the buffer which takes extra time, instead just use a newline character **<br  />
**.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider not use cout &lt;&lt; "Hello World" &lt;&lt; <strike>endl</strike>; Instead use cout &lt;&lt; "Hello World\n"; </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_range</a>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>, <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a>){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>; i != <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a>; ++i)</div>
<div class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_range</a>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>, <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a>){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>; i != <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a>; ++i)</div>
<div class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a432111147038972f06e049e18a837002"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a></div><div class="ttdeci">GLuint GLuint end</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01571">SDL_opengl.h:1571</a></div></div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_ac55adc720a3098c1b454d2a4647f4361"><div class="ttname"><a href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a></div><div class="ttdeci">GLuint start</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01571">SDL_opengl.h:1571</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Using a <b>for loop</b> by index when a range-based for loop expresses the intent better, in this case, I don't really care at all about the index. Instead, use a range-based for loop. There's no index so, one less chance for an accidental typo of off by one error.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider not use a <b>for loop by index</b>. Instead, use a <b>range-based for loop</b>. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">train_model</a>(<span class="keyword">const</span> std::vector&lt;int&gt; &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>, <span class="keyword">auto</span> &amp;<a class="code hl_class" href="class_vector__2d.html">model</a>){</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>.size(); ++i)</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">model</a>.update(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>[i]);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">train_model</a>(<span class="keyword">const</span> std::vector&lt;int&gt; &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>, <span class="keyword">auto</span> &amp;<a class="code hl_class" href="class_vector__2d.html">model</a>){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>)</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">model</a>.<a class="code hl_class" href="class_vector__2d.html">update</a>(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a740d7f00b044f54a556c7208e01f9f02"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a></div><div class="ttdeci">GLint GLenum GLsizei GLsizei GLsizei GLint GLsizei const GLvoid * data</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01974">SDL_opengl.h:1974</a></div></div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_abe1577120f1766eff913e9a74879f373"><div class="ttname"><a href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a></div><div class="ttdeci">GLint GLint GLint GLint GLint x</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01574">SDL_opengl.h:1574</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Using a <b>loop</b> when <b>standard algorith</b> already exists to do what you're trying to do. There's some simple thing that you want to do like find the index of the first positive number in vector. It's so simple though you decided to just write it by yourself. Instead, consider if there's an algorithm that already does what you're to do. In this case, we can use <b>std::find_if</b> to find where the first positive element is. <blockquote class="doxtable">
<p>&zwj;First, looking for standard algorithm, to do what you need. Before writing your's code. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">know_your_algorithms</a>() {</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a> = {-1, -3, -5, 8, 15, -1};</div>
<div class="line">    std::size_t <a class="code hl_class" href="class_vector__2d.html">first_pos_idx</a>;</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>.size(); ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>[i] &gt; 0){</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">first_pos_idx</a> = i;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">know_algorithms</a>() {</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a> = {-1, -3, -5, 8, 15, -1};</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">is_positive</a> = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>) { <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> &gt; 0; };</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">first_pos_it</a> = std::find_if(</div>
<div class="line">            <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>.cbegin(),</div>
<div class="line">            <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>.cend(),</div>
<div class="line">            <a class="code hl_class" href="class_vector__2d.html">is_positive</a>);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Using a <b>C style array</b> when you could have used a <b>standard arry</b>. C style arrays often decay into pointers and require you to pass the length of the array along with the array itself. This is just another opportunity to make a **_typo_**. Instead use a standard array.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>(<span class="keywordtype">int</span> *<a class="code hl_class" href="class_vector__2d.html">arr</a>, <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>){</div>
<div class="line">    <span class="comment">// Whatever</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">using_c_array</a>() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> = 256;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">arr</a>[<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>] = {0};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>(<a class="code hl_class" href="class_vector__2d.html">arr</a>, <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> size&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">better_f</a>(std::array&lt;int, size&gt; &amp;<a class="code hl_class" href="class_vector__2d.html">arr</a>) {</div>
<div class="line">    <span class="comment">//Whatever</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">using_c_array</a>() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> = 256;</div>
<div class="line">    std::array&lt;int, n&gt; <a class="code hl_class" href="class_vector__2d.html">arr</a>{};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">better_f</a>(<a class="code hl_class" href="class_vector__2d.html">arr</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a7a611b28eaed9ea8dda79c38887b3f0e"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a></div><div class="ttdeci">GLfloat f</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02144">SDL_opengl_glext.h:2144</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ac0a41baf8b02de6cb4211d7f15f4872e"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a></div><div class="ttdeci">GLdouble n</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02226">SDL_opengl_glext.h:2226</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Any use of <b>reinterpret_cast</b>. Pretty much the only thing you're allowed to do with an object that you got from reinterpret cast is to reinterpret cast it back to the original type. Almost everything else is undefined behavior, and yes the same goes for C-style casting. Famous Quake three algorithm for computing the inverse square root, reinterpreting the bytes of a float as a long is actually undefined behavior. You're always allowed to reinterpret cast the address of an object as a <b>character type</b>. This allows you to inspect or print out the bytes taht make up the object, so you cas see its memory laout. However, <b>as of C++ 20</b>, this use of reinterpret cast is also not necessary, <b>bit_cast</b> interprets the bytes of one object as a different type. In this case, I can cast any object to an array of bytes of the same size.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider not use <strike>interpret_cast</strike> instead, use it to cast an object to char or use bit_cast introduced in c++ 20. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">any_use_of_reinterpret_cast</a>() {</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> = 0;</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">xp</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b907a03236685c534d89d604cff23c8">x2</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(<a class="code hl_class" href="class_vector__2d.html">xp</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">any_cast_of_reinterpret_cast</a>() { <span class="comment">// C-style casting</span></div>
<div class="line">    <span class="keywordtype">float</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = .123f;</div>
<div class="line">    <span class="keywordtype">long</span> i = *(<span class="keywordtype">long</span> *) &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>; <span class="comment">// Sorry famous Quake III inv_sqrt code</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = *(<span class="keywordtype">float</span> *) &amp;i;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_bytes</a>(<span class="keyword">const</span> <a class="code hl_class" href="class_vector__2d.html">T</a> &amp;<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>) {</div>
<div class="line">    <span class="keyword">auto</span> *<a class="code hl_class" href="class_vector__2d.html">bytes</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::byte *<span class="keyword">&gt;</span>(&amp;<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>); <span class="comment">// cast an object as a character type alwasy allowed</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print out bytes one at a time</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_bytes</a>(<span class="keyword">const</span> <a class="code hl_class" href="class_vector__2d.html">T</a> &amp;<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>) {</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_vector__2d.html">bytearray</a> = std::array&lt;std::byte, <span class="keyword">sizeof</span>(<a class="code hl_class" href="class_vector__2d.html">T</a>)&gt;;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_class" href="class_vector__2d.html">bytes</a> = std::bit_cast&lt;bytearray, T&gt;(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>); <span class="comment">// bit_cast interpret the bytes of one object as different type **(c++ 20)**.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print out bytes one at a time</span></div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a1675d9d7bb68e1657ff028643b4037e3"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a></div><div class="ttdeci">GLint GLint GLint GLint GLint GLint y</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l01574">SDL_opengl.h:1574</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a7b907a03236685c534d89d604cff23c8"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a7b907a03236685c534d89d604cff23c8">x2</a></div><div class="ttdeci">GLfixed GLfixed x2</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l05506">SDL_opengl_glext.h:5506</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ad3c78daa7d8673f71649d4840c641779"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a></div><div class="ttdeci">GLenum GLenum GLenum input</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l11270">SDL_opengl_glext.h:11270</a></div></div>
</div><!-- fragment --><ol type="1">
<li><b>Casting away const</b>. This function takes in a map that maps strings to the number of times that they've occurred. It takes two words and then returns back to you whichever one has a higher count. The first way you might try to implement this is by looking up the counts of the two words, and then if the first count is bigger than the second then returning the first word. If I try to compile this, I get a weird error message telling me that the method isn't marked const, and that's how we ended up with this code. I know that I'm not modifying the map. Right? The correct thing to do this case <b>is not to cast awsy const</b>. But to instead, **use the <em>at</em> method, at is a const version of operator square bracket that throws if the word isn't in the map. But you might ask: Why don't they just add a const version so that this would compile?</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider not use <strike>const_cast</strike> instead use, .at method. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> std::string &amp;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">more_frequent</a>(<span class="keyword">const</span> std::unordered_map&lt;std::string, int&gt;) &amp;<a class="code hl_class" href="class_vector__2d.html">word_counts</a>,</div>
<div class="line">              <span class="keyword">const</span> std::string &amp;<a class="code hl_class" href="class_vector__2d.html">word1</a>,</div>
<div class="line">              <span class="keyword">const</span> std::string &amp;<a class="code hl_class" href="class_vector__2d.html">word2</a>) {</div>
<div class="line">    <span class="keyword">auto</span> &amp;<a class="code hl_class" href="class_vector__2d.html">counts</a> = <span class="keyword">const_cast&lt;</span>std::unordered_map&lt;std::string, int&gt; &amp;<span class="keyword">&gt;</span>(<a class="code hl_class" href="class_vector__2d.html">word_counts</a>);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">word_counts</a>[<a class="code hl_class" href="class_vector__2d.html">word1</a>] &gt; <a class="code hl_class" href="class_vector__2d.html">word_counts</a>[<a class="code hl_class" href="class_vector__2d.html">word2</a>] ? <a class="code hl_class" href="class_vector__2d.html">word1</a> : <a class="code hl_class" href="class_vector__2d.html">word2</a>;</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::string &amp;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">more_frequent</a>(<span class="keyword">const</span> std::unordered_map&lt;std::string, int&gt;) &amp;<a class="code hl_class" href="class_vector__2d.html">word_counts</a>,</div>
<div class="line">              <span class="keyword">const</span> std::string &amp;<a class="code hl_class" href="class_vector__2d.html">word1</a>,</div>
<div class="line">              <span class="keyword">const</span> std::string &amp;<a class="code hl_class" href="class_vector__2d.html">word2</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">word_counts</a>.at(<a class="code hl_class" href="class_vector__2d.html">word1</a>) &gt; <a class="code hl_class" href="class_vector__2d.html">word_counts</a>.at(<a class="code hl_class" href="class_vector__2d.html">word2</a>) ? <a class="code hl_class" href="class_vector__2d.html">word1</a> : <a class="code hl_class" href="class_vector__2d.html">word2</a>;</div>
<div class="line">              }</div>
</div><!-- fragment --><ol type="1">
<li><b>Not Knowing map bracket inserts element</b>. This brings us to not knowing that operator square brackets inserts the element into the map if it doesn't already exist. That's right, simply trying to look up this word in the map actually inserts it with a count of zero into the map.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;The square brackets insert the element into the map if it not already exist. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line">...</div>
<div class="line">return <a class="code hl_class" href="class_vector__2d.html">word_counts</a>[<a class="code hl_class" href="class_vector__2d.html">word1</a>] &gt; <a class="code hl_class" href="class_vector__2d.html">word_counts</a>[<a class="code hl_class" href="class_vector__2d.html">word2</a>] ? <a class="code hl_class" href="class_vector__2d.html">word1</a> : <a class="code hl_class" href="class_vector__2d.html">word2</a>;</div>
</div><!-- fragment --><ol type="1">
<li><b>Ignoring const correctness</b>. This function loops over a vector simply printing out each element one element per line. It doesn't modify the vector. So, we could and should mark the vector const. This is doubly important for a function parameter, so that the caller knows that they can use this function without their vector being modified.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_vec_one_per_line</a>(std::vector&lt;int&gt; &amp;<a class="code hl_class" href="class_vector__2d.html">arr</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_class" href="class_vector__2d.html">arr</a>) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">print_vec_one_per_line</a>(<span class="keyword">const</span> std::vector&lt;int&gt; &amp;<a class="code hl_class" href="class_vector__2d.html">arr</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_class" href="class_vector__2d.html">arr</a>) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Not knowing about <b>string literal lifetimes</b>. String literals like this one are guaranteed to live for the entire life of a program. So, it's perfectly fine to return this, even though it looks like it's a reference to a local variable.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;string literal lifetime must knowing. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code hl_class" href="class_vector__2d.html">string_literal_lifetimes</a>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;string literals&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Using <b>structured bindings</b>. Here we have a map of color names to their hex values. Then we just loop over all the pairs and print out the name and hex value. It would be a lot more readable if we could refer to these things as name and hex rather that pair.first and <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">pair.second</a>. Well, that's exactly what a structured binding lets us do. We grab the pair by reference. Then, the structured binding introduce name and hex as names for the first and second elements of the pair. Structured bindings can also be used with your own types if the members are public. The names get assigned to the variables according to the order of their declarations.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider not using structured bindings Instead, use two parameters with loop. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">loop_map_items</a>() {</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; colors = {</div>
<div class="line">        {<span class="stringliteral">&quot;RED&quot;</span>, <span class="stringliteral">&quot;#FF0000&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;GREEN&quot;</span>, <span class="stringliteral">&quot;#00FF00&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;BLUE&quot;</span>, <span class="stringliteral">&quot;#0000FF&quot;</span>}</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_class" href="class_vector__2d.html">pair</a>: colors){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;name: &quot;</span> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">pair</a>.first &lt;&lt; <span class="stringliteral">&quot;, hex&quot;</span> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">pair</a>.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">loop_map_items</a>() {</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; colors = {</div>
<div class="line">        {<span class="stringliteral">&quot;RED&quot;</span>, <span class="stringliteral">&quot;#FF0000&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;GREEN&quot;</span>, <span class="stringliteral">&quot;#00FF00&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;BLUE&quot;</span>, <span class="stringliteral">&quot;#0000FF&quot;</span>}</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>, <a class="code hl_class" href="class_vector__2d.html">hex</a>]: colors){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;name: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a> &lt;&lt; <span class="stringliteral">&quot;, hex&quot;</span> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">hex</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a8e1a4ccadfc12dbf9a8e411d68adfe8e"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a></div><div class="ttdeci">GLuint const GLchar * name</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00952">SDL_opengl_glext.h:952</a></div></div>
</div><!-- fragment --><p>also structured bindings.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">S</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>;</div>
<div class="line">};</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">S</a> <a class="code hl_class" href="class_vector__2d.html">get_S</a>();</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">use_S</a>() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [<a class="code hl_class" href="class_vector__2d.html">name_for_a</a>, <a class="code hl_class" href="class_vector__2d.html">name_for_s</a>] = <a class="code hl_class" href="class_vector__2d.html">get_S</a>();</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ac8729153468b5dcf13f971b21d84d4e5"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a></div><div class="ttdeci">GLboolean GLboolean GLboolean GLboolean a</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l01417">SDL_opengl_glext.h:1417</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Out-params instead of returning a struct, using multiple out parameters when you want to return multiple things from a function. Instead, create a basic struct and give those things names. Then, you can return the multiple values that you wanted to by returning the struct instead. The caller can even make it look like it was multiple values returned by using structured bindings.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider, not use function return multiple things. Instead, use struct and give those things names. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">get_values_out_params</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>, <span class="keywordtype">int</span> &amp;<a class="code hl_class" href="class_vector__2d.html">out1</a>, <span class="keywordtype">int</span> &amp;<a class="code hl_class" href="class_vector__2d.html">out2</a>) {</div>
<div class="line">    <span class="comment">// do stuff</span></div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">out1</a> = <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>;</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">out2</a> = <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>+1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Values</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">Values</a></div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">get_values_return_struct</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>, <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>+1};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">use_values</a>(){</div>
<div class="line">    <span class="keyword">auto</span> [<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>] = <a class="code hl_class" href="class_vector__2d.html">get_values_return_struct</a>(2);</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Doing work at runtime that could have been done at compile time. Here's a function that gives the formula for the sum of the first n integers. Sometimes, the parameters might be know at compile-time and you could do the calculation ahead of time. Go ahead and let the compiler know that it's totally fine to compute this ahead of time.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider, not doing work at runtime that can done on compile time. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">sum_of_1_to_n</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> * (<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>+1) / 2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">uses_sum</a>() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a702e6dc059ad96a3ec3e24fd769fd6ac">limit</a> = 1000;</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">triangle_n</a> = <a class="code hl_class" href="class_vector__2d.html">sum_of_1_to_n</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a702e6dc059ad96a3ec3e24fd769fd6ac">limit</a>);</div>
<div class="line">    <span class="comment">// use triangle_n...</span></div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a702e6dc059ad96a3ec3e24fd769fd6ac"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a702e6dc059ad96a3ec3e24fd769fd6ac">limit</a></div><div class="ttdeci">GLint limit</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l10409">SDL_opengl_glext.h:10409</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">sum_of_1_to_n</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> * (<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>+1) / 2;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Forgetting to mark destructors virtual. If a derived class gets deleted through a pointer to this base class, then the derived class destructor will not be called only the base classes destructor will be called. Here, I have a class that derives from the base that doesn't have a virtual destructor. This function expects a pointer to the base class. It uses some base functionality and then deletes the pointer when it's done. This will happen automatically since I'm using a unique pointer. But the same would be true if you just took in a normal pointer and then manually called delete. If you pass a pointer to an instance of this derived type, then the wrong destructor gets called at the end. To make sure the correct destructor is called even through a pointer to a base class, you need to make the function virtual. It's also good practice to explicitly mark the derived classes destructor as override.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Be carefull to mark destructor of, pointer class virtually. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">BaseWithNonvirtualDestructor</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">foo</a>() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;do foo\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">~BaseWithNonvirtualDestructor</a>() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;called base destructor\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">Derived</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_vector__2d.html">BaseWithNonvirtualDestructor</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">~Derived</a>() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;called derived destructor\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">consume_base</a>(std::unique_ptr&lt;BaseWithNonvirtualDestructor&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>) {</div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>-&gt;foo();</div>
<div class="line">    <span class="comment">// deletes p when done</span></div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_aa5367c14d90f462230c2611b81b41d23"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a></div><div class="ttdeci">GLfloat GLfloat p</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l13126">SDL_opengl_glext.h:13126</a></div></div>
<div class="ttc" id="aclass_vector__2d_html_a6d09fb691e01f179efcbef03bef13b9c"><div class="ttname"><a href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Vector_2d::Vector_2d</a></div><div class="ttdeci">Vector_2d()</div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8cpp_source.html#l00018">Vector_2d.cpp:18</a></div></div>
</div><!-- fragment --><p>to ensure that the correct destructor called</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">BaseWithNonvirtualDestructor</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">foo</a>() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;do foo\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">~BaseWithNonvirtualDestructor</a>() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;called base destructor\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">Derived</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_vector__2d.html">BaseWithNonvirtualDestructor</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">~Derived</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;called derived destructor\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">consume_base</a>(std::unique_ptr&lt;BaseWithNonvirtualDestructor&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>) {</div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a>-&gt;foo();</div>
<div class="line">    <span class="comment">// deletes p when done</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Thinking that class members are initalized in the order they appear in the initializer list. Reading left to right this looks fine. The actual order that members are initialized in is the order that they're declared in. First, we initialize end as start plus size but this m start is garbage. It hasn't been initialized yet. We can of course fix this by declaring start first instead. Or, since start is also a parameter to the function, we could just define the end variable in terms of the start parameter</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">View</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">View</a>(<span class="keywordtype">char</span> *<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>, std::size_t <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>) : <a class="code hl_class" href="class_vector__2d.html">m_start</a>{<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>}, <a class="code hl_class" href="class_vector__2d.html">m_end</a>{<a class="code hl_class" href="class_vector__2d.html">m_start</a> + <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>} {</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">char</span> *<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">m_end</a>;</div>
<div class="line">    <span class="keywordtype">char</span> *<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">m_start</a>;</div>
<div class="line">};</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a9f139c614d49f2a707b6037305b0fec0"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a></div><div class="ttdeci">GLsizeiptr size</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00829">SDL_opengl_glext.h:829</a></div></div>
</div><!-- fragment --><p>correct this by</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">View</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">View</a>(<span class="keywordtype">char</span> *<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>, std::size_t <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>) : <a class="code hl_class" href="class_vector__2d.html">m_start</a>{<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#ac55adc720a3098c1b454d2a4647f4361">start</a>}, <a class="code hl_class" href="class_vector__2d.html">m_end</a>{<a class="code hl_class" href="class_vector__2d.html">m_start</a> + <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>} {</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">char</span> *<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">m_start</a>;</div>
<div class="line">    <span class="keywordtype">char</span> *<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">m_end</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><ol type="1">
<li>Not realizing there's a difference between default and value initialization, x and x2 are default initialized. They contain garbage until you put something into them, y, y2 and y3 are value initialized. They are guaranteed to contain the value zero, z, on the other hand, is neither default nor value initialized. This is a function declaration. Even if it's a tiny bit less efficient, initializing your values is almost always a good idea. The same kind of thing goes if you have an aggregate or array type. In the first two cases, n and m are zero and S is the empty string. Notice that, even with default initialization, the empty string did still get initialized. That's because for both default and value initialization if you define a default constructor, it will be called.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">default_vs_value_initialization</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    <span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b907a03236685c534d89d604cff23c8">x2</a> = <span class="keyword">new</span> int;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>{};</div>
<div class="line">    <span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a2be1135ed68e8d80fa9e130c7814f8c2">y2</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>{};</div>
<div class="line">    <span class="keywordtype">int</span> *<a class="code hl_class" href="class_vector__2d.html">y3</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>{};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1c599441d9dece861ee2cd70e31ce120">z</a>();</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a1c599441d9dece861ee2cd70e31ce120"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a1c599441d9dece861ee2cd70e31ce120">z</a></div><div class="ttdeci">GLdouble GLdouble z</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00702">SDL_opengl_glext.h:702</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a2be1135ed68e8d80fa9e130c7814f8c2"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a2be1135ed68e8d80fa9e130c7814f8c2">y2</a></div><div class="ttdeci">GLfixed GLfixed GLfixed y2</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l05506">SDL_opengl_glext.h:5506</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">S</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>, <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">default_vs_value_initialization</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">S</a> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">S</a> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a7b907a03236685c534d89d604cff23c8">x2</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">S</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">S</a> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>{};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">S</a> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a2be1135ed68e8d80fa9e130c7814f8c2">y2</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">S</a>{};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">S</a> *<a class="code hl_class" href="class_vector__2d.html">y3</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">S</a>();</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_af593500c283bf1a787a6f947f503a5c2"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a></div><div class="ttdeci">const GLfloat * m</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l07099">SDL_opengl_glext.h:7099</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Overuse of <b>magic numbers</b>. Introducing a basic constant in your code can make it many times more readable. The compiler is going to optimize it away anyway. Just give it a good name.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">float</span> <a class="code hl_class" href="class_vector__2d.html">energy</a>(<span class="keywordtype">float</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a> * 299792458.0 * 299792458.0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> <a class="code hl_class" href="class_vector__2d.html">energy</a>(<span class="keywordtype">float</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a>) {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">float</span> <a class="code hl_class" href="class_vector__2d.html">SPEED_OF_LIGHT</a> = 299792458.0;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af593500c283bf1a787a6f947f503a5c2">m</a> * <a class="code hl_class" href="class_vector__2d.html">SPEED_OF_LIGHT</a> * <a class="code hl_class" href="class_vector__2d.html">SPEED_OF_LIGHT</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Attempting to <b>add or remove elements</b> from a container while looping over it. Well, doing that is sometimes just necessary but what I mean is noobs often do it incorrectly. Wer'e trying to put a copy of the vector at the end of the vector. Adding or removing an element to the vector may invalidate the iterators to the vector. For example, push_back might need to resize the vector and move all the elements to a new location. After moving the contents of the vector to a new location, you can't expect the end pointer to be the same. You would run into the exact same issue. In fact, it's probably clearer why you would run into this issue if you used iterators directly. This is a case where using a loop index actually does solve the problem. It doesn't matter if the contents of your vector get moved somewhere else the ith element is still the ith element.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">modify_while_iterating</a>() {</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>{1, 2, 3, 4};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> : <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>){</div>
<div class="line">        <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.push_back(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">modify_while_iterating</a>() {</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>{1, 2, 3, 4};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">it</a> = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.begin(), <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a> = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.end() ; <a class="code hl_class" href="class_vector__2d.html">it</a> != <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end</a>; ++i) {</div>
<div class="line">        <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.push_back(*<a class="code hl_class" href="class_vector__2d.html">it</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">modify_while_iterating</a>() {</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>{1, 2, 3, 4};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::size_t <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a> = <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.size();</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>; ++i)</div>
<div class="line">        <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>.push_back(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>[i]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>: <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>) {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a55f85da29bf761fde63cc95d26300230"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a></div><div class="ttdeci">const GLdouble * v</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l02064">SDL_opengl.h:2064</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Returning a <b>moved local variable</b>. I totally get where you're come from. A vector can be a large object and you don't want to make a copy of it. So, you go ahead and try to move it out. If you had just tried to return v directly, there would have been no copy and no move. In this situation, that's because of return value optimization. But what if the compiler can't do return value optimization. In all cases, the move is unnecessary. The compiler always knows that it can move a local variable. But in some cases, this actively prevents return value optimization. So, that's why this is one of the few rules where I can say you should just never do this.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::vector&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">make_vector</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>) {</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>{1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do whatever with vector</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::move(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>); <span class="comment">// or return v;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;int&gt; <a class="code hl_class" href="class_vector__2d.html">make_vector</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>) {</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>{1, 2, 3, 4, 5};</div>
<div class="line">    std::vector&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a>{1, 2};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a> == 0)</div>
<div class="line">        <span class="keywordflow">return</span> std::move(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a55f85da29bf761fde63cc95d26300230">v</a>);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> std::move(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_afb1b07e1b25035d41d60fb2c03d507e6"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a></div><div class="ttdeci">GLubyte GLubyte GLubyte GLubyte w</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l01023">SDL_opengl_glext.h:1023</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Thinking that <b>move actually moves something</b>. Here is an implementation of standard move. The full templated definition might be a bit much to take in all at once. So, let's take a look just at the int case. Move takes in an int lvalue reference, static casts it to an rvalue reference and returns it. The exact same thing happens in the or value overload. It just static casts to an rvalue and returns it. A more accurate name for move is probably something like cast to rvalue.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">constexpr</span> std::remove_reference_t&lt;T&gt; &amp;&amp;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">move</a>(<a class="code hl_class" href="class_vector__2d.html">T</a> &amp;&amp;<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac783c2a5a0d42f36a33959f6a34ae0ba">value</a>) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::remove_reference_t&lt;T&gt; &amp;&amp;<span class="keyword">&gt;</span>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac783c2a5a0d42f36a33959f6a34ae0ba">value</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span>&amp;&amp;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">move</a>(<span class="keywordtype">int</span> &amp;<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac783c2a5a0d42f36a33959f6a34ae0ba">value</a>) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span> &amp;&amp;<span class="keyword">&gt;</span>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac783c2a5a0d42f36a33959f6a34ae0ba">value</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ac783c2a5a0d42f36a33959f6a34ae0ba"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ac783c2a5a0d42f36a33959f6a34ae0ba">value</a></div><div class="ttdeci">GLsizei const GLfloat * value</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00990">SDL_opengl_glext.h:990</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Thinking that evaluation order is guaranteed to be left to right. Here's a famous example, we have a string that says, "but I have heard it works even if you don't believe in it". We replace the first four characters with the empty string. Then, we find even and replace it with only. Then, we find don't and delete it. With this reasoning, we should end up with: "I have heard it works only if you believe in it". But prior to C++ 17, the compiler is actually allowed to compute any sub-expression in any order. So theoretically, it could find the location of even first and then replace the first four characters making that location off by four. So, then when the second replace happens it would replace these four characters with only and you can see how this goes on you don't get the result you expected. Well, the good news is that as of C++ 17, this example is guaranteed. If yoiu have a.b, then a is guaranteed to be evaluated before b is. However, even in C++ 20, the order that function arguments are evaluated is still not guaranteed left to right. This wouldn't matter much if a b and c were pure function. But, if a b and c have side effects, then the order that they're called in might actually make a difference.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">function_evaluation_order_not_guaranteed</a>() {</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a> = <span class="stringliteral">&quot;but i have heard it works even if you don&#39;t believe in it&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>.replace(0, 4, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">        .replace(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>.find(<span class="stringliteral">&quot;even&quot;</span>), 4, <span class="stringliteral">&quot;only&quot;</span>)</div>
<div class="line">        .replace(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>.find(<span class="stringliteral">&quot;don&#39;t&quot;</span>), 6, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code hl_class" href="class_vector__2d.html">expected</a> = <span class="stringliteral">&quot;but i have heard it works even if you don&#39;t believe in it&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>();</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>();</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a>();</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9cd653b1648845554169fbc3a3f6d37a">g</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">function_evaluation_order_not_guaranteed</a>() {</div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a9cd653b1648845554169fbc3a3f6d37a">g</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>(), <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>(), <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a>());</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a1f2d7f8147412c43ba2303a56f97ee73"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a></div><div class="ttdeci">const GLubyte * c</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l13129">SDL_opengl_glext.h:13129</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a6eba317e3cf44d6d26c04a5a8f197dcb"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a></div><div class="ttdeci">GLboolean GLboolean GLboolean b</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l01417">SDL_opengl_glext.h:1417</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a9cd653b1648845554169fbc3a3f6d37a"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a9cd653b1648845554169fbc3a3f6d37a">g</a></div><div class="ttdeci">GLboolean GLboolean g</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l01417">SDL_opengl_glext.h:1417</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Using totally <b>unnecessary heap allocations</b> when a stack allocation would have been fine. Here, we create two customer records on the heap. Then, we do some work and then we end up deleting those variables at the end of function. The question we should ask ourselves is: Did this really need to be a heap allocation? There's a good chance it would have been fine if we just stack-allocated them. So, let's just say for the sake of argument that these objects are too big and you really do want them on the heap. &gt; Don't use heap allocations when, &gt; it's not really needed. &gt; Heap allocations is slower than &gt; Stack-allocations.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Record</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">unnecessary_heap_allocations</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> *<a class="code hl_class" href="class_vector__2d.html">customer</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{0, <span class="stringliteral">&quot;James&quot;</span>};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> *<a class="code hl_class" href="class_vector__2d.html">other</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{1, <span class="stringliteral">&quot;Someone&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span> <a class="code hl_class" href="class_vector__2d.html">customer</a>;</div>
<div class="line">    <span class="keyword">delete</span> <a class="code hl_class" href="class_vector__2d.html">other</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Record</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">unnecessary_heap_allocations</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> <a class="code hl_class" href="class_vector__2d.html">customer</a>{0, <span class="stringliteral">&quot;James&quot;</span>};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> <a class="code hl_class" href="class_vector__2d.html">other</a>{1, <span class="stringliteral">&quot;Someone&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work ...</span></div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a58c2a664503e14ffb8f21012aabff3e9"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a></div><div class="ttdeci">GLuint id</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l00820">SDL_opengl_glext.h:820</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Not using <b>unique pointer and shared pointer</b> to do your heap allocations. What happens if an exception gets thrown in the middle here? Then, these deletes never occur and the memory is leaked. When you want to make sure that a resource is cleaned up, you need to put that cleanup code in a destructor. So, why don't we make a class that holds a pointer, and then in its destructor it deletes that pointer. Well, that's exactly what <em>unique_ptr</em> does. You can give it a heap-allocated pointer and when it goes out of scope, it deletes is. A <em>shared pointer</em> on the other hand uses a <b>reference-counting scheme</b>, similar to what you might have in a language like Python. When the reference count hits zero at the last shared pointer goes out of scope that shared pointer is in charge of the deletion. This scheme is much more expensive because reference incrementing and decrementing have to be done atomically.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Consider using unique_ptr and shared_ptr. to ensure not going to leaked memory. </p>
</blockquote>
<div class="fragment"><div class="line"> ++</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Record</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">unnecessary_heap_allocations</a>() {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> *<a class="code hl_class" href="class_vector__2d.html">customer</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{0, <span class="stringliteral">&quot;James&quot;</span>};</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">Record</a> *<a class="code hl_class" href="class_vector__2d.html">other</a> = <span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{1, <span class="stringliteral">&quot;Someone&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work  EXCEPTION &lt;----</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span> <a class="code hl_class" href="class_vector__2d.html">customer</a>; <span class="comment">// not worked and memory leaked</span></div>
<div class="line">    <span class="keyword">delete</span> <a class="code hl_class" href="class_vector__2d.html">other</a>; <span class="comment">// same</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Record</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">unnecessary_heap_allocations</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">customer</a> = std::unique_ptr&lt;Record&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{0, <span class="stringliteral">&quot;James&quot;</span>});</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">other</a> = std::unique_ptr&lt;Record&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{1, <span class="stringliteral">&quot;Someone&quot;</span>});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work  EXCEPTION &lt;----</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">unnecessary_heap_allocations</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">customer</a> = std::shared_ptr&lt;Record&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{0, <span class="stringliteral">&quot;James&quot;</span>});</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">other</a> = std::shared_ptr&lt;Record&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_vector__2d.html">Record</a>{1, <span class="stringliteral">&quot;Someone&quot;</span>});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work  EXCEPTION &lt;----</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li><b>Constructing a unique or shared pointer</b> directly instead of using make unique or make shared. make_unique and make_shared will pass your arguments directly to the constructor of your object.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Record</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Record</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::string <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>) : <a class="code hl_class" href="class_vector__2d.html">id</a>{<a class="code hl_class" href="class_vector__2d.html">id</a>}, <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>{<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>} {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">necessary_heap_allocations</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">customer</a> = std::make_unique&lt;Record&gt;(0, <span class="stringliteral">&quot;James&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">other</a> = std::make_shared&lt;Record&gt;(1, <span class="stringliteral">&quot;Someone&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do work  EXCEPTION &lt;----</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Any use of <b>new</b> or <b>delete</b>. There's no reason to rewrite functionality that already exists. Here, I'm trying to manage the memory of some resource and then delete it when it's done. That's already what a unique pointer does. Don't try to couple the purpose of your class to the idea of ownership of an object. That's a completely separate issue. Unique pointer and shared pointer together cover pretty much every valid use of new or delete.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">SomeResource</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">Widget</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">widget</a>() : <a class="code hl_class" href="class_vector__2d.html">meta</a>{<a class="code hl_class" href="class_vector__2d.html">new</a> <a class="code hl_class" href="class_vector__2d.html">SomeResource</a>{}} {</div>
<div class="line">        <span class="comment">// whatever</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">~Widget</a>() {</div>
<div class="line">        <span class="keyword">delete</span> <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">meta</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">SomeResource</a> *<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">meta</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">SomeResource</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_vector__2d.html">Widget</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">widget</a>() : <a class="code hl_class" href="class_vector__2d.html">meta</a>{<a class="code hl_namespace" href="namespacestd.html">std</a>::<a class="code hl_class" href="class_vector__2d.html">make_unique</a>&lt;<a class="code hl_class" href="class_vector__2d.html">SomeResource</a>&gt;()} {</div>
<div class="line">        <span class="comment">// whatever</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;SomeResource&gt; <a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">meta</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><ol type="1">
<li>Any kind of attempt to do <b>manual resource management</b>. Thsi is pretty much the same story as with new and delete. If you find yourself manually freeing closing or releasing any kind of resource, then look to see if there's a class that does that automatically. By the way, this idea of having resource automatically close in a destructor is called RAII. It stands for <b>Resource Acquisition</b> Is Initialization. But it really has more to do with ensuring taht resources are released upon destruction. &gt; Consider looking for a class that &gt; automatically manage resource like RAII.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">read_from_a_file</a>(<span class="keywordtype">char</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>) {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">FILE</a> *fp = <a class="code hl_class" href="class_vector__2d.html">fopen</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">    <span class="comment">// ... work with file, EXCEPTION?</span></div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">fclose</a>(fp);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">read_from_a_file</a>(<span class="keywordtype">char</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>) {</div>
<div class="line">    std::ifstream <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>{<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a8e1a4ccadfc12dbf9a8e411d68adfe8e">name</a>}; <span class="comment">// RAII</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// file will be closed</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Thinking that <b>raw pointers</b> are shomehow bad. Here's a basic max function. This function is just reading from the pointers. It doesn't care at all who's in charge of deleting them. If your function doesn't have anything to do with the ownership of the objects in question, then there's no need to use smart pointers. The convention is that raw pointers don't own what they're pointing to. And this should not be confused with the const-ness of the pointer. This add function adds the source into the destination. But this function is not in charge of the lifetime of either of the pointers. Of course, if you're interoperating with C code, code is not going to share this convention. A C-function might very well return some heap-allocated memory to you that it expects you to delete. Be careful though, if you've got a pointer with malloc you need to delete it with free. You can't just let unique try to delete it with the built-in delete. You can still use a unique pointer though. You just need to define your own deleter which uses free.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::shared_ptr&lt;int&gt;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">max</a>(std::shared_ptr&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>, std::shared_ptr&lt;int&gt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> &gt; *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a> ? <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>: <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">max</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> &gt; *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a> ? <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>: <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> add(<span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a85e59cd56e10d0a7f49ab199f277d486">dst</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a2a98ddb6f79ec1048ff9e15cdd2422ba">src</a>) {</div>
<div class="line">    *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a85e59cd56e10d0a7f49ab199f277d486">dst</a> += *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a2a98ddb6f79ec1048ff9e15cdd2422ba">src</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *<a class="code hl_class" href="class_vector__2d.html">some_c_function</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">do_work</a>() {</div>
<div class="line">    <span class="keywordtype">char</span> *<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a> = <a class="code hl_class" href="class_vector__2d.html">some_c_function</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> *<a class="code hl_class" href="class_vector__2d.html">some_c_function</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">do_work</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a> = std::unique_ptr&lt;int&gt;(<a class="code hl_class" href="class_vector__2d.html">some_c_function</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> *<a class="code hl_class" href="class_vector__2d.html">some_c_function</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">FreeDeleter</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keywordtype">void</span>* <a class="code hl_class" href="class_vector__2d.html">X</a>) {<a class="code hl_function" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">free</a>(<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>)}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">do_work</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a> = std::unique_ptr&lt;int, FreeDeleter&gt;(<a class="code hl_class" href="class_vector__2d.html">some_c_function</a>());</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a2a98ddb6f79ec1048ff9e15cdd2422ba"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a2a98ddb6f79ec1048ff9e15cdd2422ba">src</a></div><div class="ttdeci">GLenum src</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02011">SDL_opengl_glext.h:2011</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a85e59cd56e10d0a7f49ab199f277d486"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a85e59cd56e10d0a7f49ab199f277d486">dst</a></div><div class="ttdeci">GLenum GLenum dst</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l02011">SDL_opengl_glext.h:2011</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Returning a <b>shared pointer</b> when you aren't sure the object is going to be shared. If a caller got a unique pointer, it's cheap and easy to convert it into a shared pointer if that's what they really need. They could even directly assign the unique pointer return value to a shared pointer. But if you return to them a shared pointer in the first place, the damage would already be done if all they really wanted was a unique pointer.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Pizza</a> {...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;Pizza&gt;</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">make_shared_pepperoni_pizza</a>(<span class="keywordtype">float</span> <a class="code hl_class" href="class_vector__2d.html">diameter</a>) {</div>
<div class="line">    std::vector&lt;std::string&gt; <a class="code hl_class" href="class_vector__2d.html">toppings</a> = {<span class="stringliteral">&quot;red sauce&quot;</span>, <span class="stringliteral">&quot;cheese&quot;</span>, <span class="stringliteral">&quot;pepperoni&quot;</span>};</div>
<div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;Pizza&gt;(<a class="code hl_class" href="class_vector__2d.html">diameter</a>, std::move(<a class="code hl_class" href="class_vector__2d.html">toppings</a>)); <span class="comment">// why shared?</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">convert_unique_to_shared_is_easy_and_cheap</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="class_vector__2d.html">Pizza</a> = <a class="code hl_class" href="class_vector__2d.html">make_unique_pepperoni_pizza</a>(16.0f);</div>
<div class="line">    std::shared_ptr&lt;Pizza&gt; <a class="code hl_class" href="class_vector__2d.html">shared_pizza</a> = std::move(<a class="code hl_class" href="class_vector__2d.html">pizza</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">convert_unique_to_shared_is_easy_and_cheap</a>() {</div>
<div class="line">    std::shared_ptr&lt;Pizza&gt; <a class="code hl_class" href="class_vector__2d.html">shared_pizza</a> = <a class="code hl_class" href="class_vector__2d.html">make_unique_pepperoni_pizza</a>(16.0f);</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Thinking that shared pointer is <b>thread-safe</b>. The reference counting part of the shared pointer is theard-safe. Here, I make a shared resource and pass it off to two worker threads. Because the reference counting is thread-safe, there's no danger that the object will fail to be deleted or be deleted twice. However, it's only the reference counting part that's atomic. This part here where we're accessing the x variable and the resource is not atomic and there's no locks. This is a plain old date race of two threads trying to modify the same memory. If you wnat to fix the data race, you need to fix it the way you'd fix any other data race.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="class_vector__2d.html">Resource</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>{};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">worker</a>(std::shared_ptr&lt;Resource&gt; <a class="code hl_class" href="class_vector__2d.html">noisy</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50000; ++i)</div>
<div class="line">        <a class="code hl_class" href="class_vector__2d.html">noisy</a>-&gt;x++;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">shared_ptr_is_NOT_threadsafe</a>() {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> = std::make_shared&lt;Resource&gt;();</div>
<div class="line">    std::jthread <a class="code hl_class" href="class_vector__2d.html">t2</a>(<a class="code hl_class" href="class_vector__2d.html">worker</a>, <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>);</div>
<div class="line">    std::jthread <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#af48031a37b713afa3b0d0d7d29653d7c">t1</a>(<a class="code hl_class" href="class_vector__2d.html">worker</a>, <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>);</div>
<div class="line">    <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>.reset();</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_abe08814c2f72843fde4d8df41440d5a0"><div class="ttname"><a href="_s_d_l__opengl_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a></div><div class="ttdeci">GLdouble GLdouble GLdouble r</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l02079">SDL_opengl.h:2079</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_af48031a37b713afa3b0d0d7d29653d7c"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#af48031a37b713afa3b0d0d7d29653d7c">t1</a></div><div class="ttdeci">GLuint GLfloat GLfloat GLfloat GLfloat GLfloat GLfloat GLfloat GLfloat GLfloat t1</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l10166">SDL_opengl_glext.h:10166</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Confusing a <b>const pointer with a pointer to const</b>. The concept of a const pointer versus pointer to const is pretty simple. But, a lot of newbies struggle to remember how to tell the difference between them symtacticlly. The rule is that const applies to whatever is immediatelly to its left. Unless it's leftmost thing, in which it applies to the thing to its right. So here, the cost applies to the int, not to the pointer. Here, the const applies to the int, not to the int.</li>
</ol>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="class_vector__2d.html">const_pointer_vs_pointer_to_const</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a> = 0;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> *<a class="code hl_class" href="class_vector__2d.html">ptr1</a> = &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> *<a class="code hl_class" href="class_vector__2d.html">ptr2</a> = &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">    <span class="keywordtype">int</span> *<span class="keyword">const</span> <a class="code hl_class" href="class_vector__2d.html">ptr3</a> = &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Ignoring <b>compiler warnings</b>. Ignoring them or turning them off very frequently leads to undefined behavior. &gt; don't ignore any compiler message.</li>
</ol>
<p>I hope you enjoyed this list of newbie C++ habits. As always thank you very much for take time and enjoy them.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
&lt;em&gt;REFERENCES&lt;/em&gt;</h1>
<ol type="1">
<li><a href="https://www.youtube.com/watch?v=i_wDa2AS_8w">youtube</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
