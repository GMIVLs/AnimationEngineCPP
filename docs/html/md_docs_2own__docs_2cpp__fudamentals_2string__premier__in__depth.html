<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimationEngineCPP: String premier in CPP - In depth</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimationEngineCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">String premier in CPP - In depth</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md170"></a> </p>
<h1><a class="anchor" id="autotoc_md171"></a>
Content</h1>
<p><b>Table of Contents</b></p>
<ul>
<li>String premier in CPP - In depth<ul>
<li>Content</li>
<li>Types of string - Commonly used</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md172"></a>
String in cpp all methods</h1>
<p>In C++, the <code>string</code> class is a part of the Standard Library, defined in the header file <code>&lt;string&gt;</code>. It represents a sequence of characters and provides various methods to manipulate and query strings. The <code>string</code> class simplifies many of the complexities of working with raw C-style character arrays.</p>
<p>Here's an overview of the <code>string</code> class in C++, including its methods and common ways to use it:</p>
<h2><a class="anchor" id="autotoc_md173"></a>
&lt;strong&gt;Construction&lt;/strong&gt;:</h2>
<ul>
<li>Default constructor: <code><a class="el" href="_s_d_l__opengl__glext_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">string()</a></code></li>
<li>Copy constructor: <code>string(const string&amp; str)</code></li>
<li>Substring constructor: <code>string(const string&amp; str, size_t pos, size_t len = npos)</code></li>
<li>From C-string: <code><a class="el" href="_s_d_l__opengl__glext_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">string(const char* s)</a></code></li>
<li>Repeat character: <code><a class="el" href="_s_d_l__opengl__glext_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">string(size_t n, char c)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md174"></a>
&lt;strong&gt;Element Access&lt;/strong&gt;:</h2>
<ul>
<li><code>at(size_t pos)</code>: Returns character at the specified position.</li>
<li><code>operator[]</code>: Access character at a specified position.</li>
<li><code>front()</code>: Returns the first character.</li>
<li><code>back()</code>: Returns the last character.</li>
<li><code>c_str()</code>: Returns a C-style character string.</li>
<li><code><a class="el" href="_s_d_l__opengl_8h.html#a740d7f00b044f54a556c7208e01f9f02">data()</a></code>: Returns a pointer to the string data.</li>
</ul>
<h2><a class="anchor" id="autotoc_md175"></a>
&lt;strong&gt;Modifiers&lt;/strong&gt;:</h2>
<ul>
<li><code>append()</code>: Append string.</li>
<li><code>push_back()</code>: Append character.</li>
<li><code>assign()</code>: Assign new content to the string.</li>
<li><code>insert()</code>: Insert content.</li>
<li><code>erase()</code>: Erase characters.</li>
<li><code>replace()</code>: Replace part of the string.</li>
<li><code>swap()</code>: Swap string values.</li>
<li><code>pop_back()</code>: Deletes the last character.</li>
</ul>
<h2><a class="anchor" id="autotoc_md176"></a>
&lt;strong&gt;Capacity&lt;/strong&gt;:</h2>
<ul>
<li><code><a class="el" href="_s_d_l__opengl__glext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size()</a></code> or <code><a class="el" href="_s_d_l__opengl__glext_8h.html#ab9c919755bde3b34349e23a32b4e0fa7">length()</a></code>: Return length.</li>
<li><code>resize()</code>: Change the size.</li>
<li><code>capacity()</code>: Returns the size of allocated storage.</li>
<li><code>reserve()</code>: Request a change in capacity.</li>
<li><code>clear()</code>: Clears the string.</li>
<li><code>empty()</code>: Checks if the string is empty.</li>
<li><code>shrink_to_fit()</code>: Reduces memory usage by freeing unused memory.</li>
</ul>
<h2><a class="anchor" id="autotoc_md177"></a>
&lt;strong&gt;Operations&lt;/strong&gt;:</h2>
<ul>
<li><code>substr()</code>: Returns a substring.</li>
<li><code>copy()</code>: Copy sequence of characters from string.</li>
<li><code>c_str()</code>: Returns a null-terminated character sequence.</li>
<li><code>find()</code>: Find content in string.</li>
<li><code>rfind()</code>: Find last occurrence of content in string.</li>
<li><code>find_first_of()</code>: Find character in string.</li>
<li><code>find_last_of()</code>: Find the last character in string.</li>
<li><code>find_first_not_of()</code>: Find character not in string.</li>
<li><code>find_last_not_of()</code>: Find the last character not in the string.</li>
<li><code>compare()</code>: Compare strings.</li>
</ul>
<h2><a class="anchor" id="autotoc_md178"></a>
&lt;strong&gt;Relational Operators&lt;/strong&gt;:</h2>
<p>Strings can be compared using relational operators like <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<h2><a class="anchor" id="autotoc_md179"></a>
&lt;strong&gt;Iterators&lt;/strong&gt;:</h2>
<ul>
<li><code>begin()</code>: Returns an iterator pointing to the first character.</li>
<li><code><a class="el" href="_s_d_l__opengl_8h.html#a432111147038972f06e049e18a837002">end()</a></code>: Returns an iterator pointing to the past-the-end character.</li>
<li><code>rbegin()</code>, <code>rend()</code>: Reverse iterators.</li>
<li><code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, <code>crend()</code>: Constant iterators.</li>
</ul>
<h2><a class="anchor" id="autotoc_md180"></a>
&lt;strong&gt;Numeric Conversions&lt;/strong&gt;:</h2>
<ul>
<li><code>stoi()</code>: Convert string to integer.</li>
<li><code>stol()</code>, <code>stoll()</code>: Convert string to long and long long.</li>
<li><code>stof()</code>, <code>stod()</code>, <code>stold()</code>: Convert string to float, double, and long double.</li>
<li><code>to_string()</code>: Convert numeric types to string.</li>
</ul>
<h2><a class="anchor" id="autotoc_md181"></a>
&lt;strong&gt;Allocator&lt;/strong&gt;:</h2>
<ul>
<li><code>get_allocator()</code>: Returns the allocator object.</li>
</ul>
<h2><a class="anchor" id="autotoc_md182"></a>
&lt;strong&gt;Member Constants&lt;/strong&gt;:</h2>
<ul>
<li><code>npos</code>: Represents the maximum size of the string, used for "until the end of the string" in various methods.</li>
</ul>
<h2><a class="anchor" id="autotoc_md183"></a>
Common Usage Patterns:</h2>
<ol type="1">
<li><p class="startli"><b>String Concatenation</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code hl_class" href="class_vector__2d.html">hello</a> = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line"><span class="keywordtype">string</span> <a class="code hl_class" href="class_vector__2d.html">world</a> = <span class="stringliteral">&quot; World!&quot;</span>;</div>
<div class="line"><span class="keywordtype">string</span> <a class="code hl_class" href="class_vector__2d.html">greeting</a> = <a class="code hl_class" href="class_vector__2d.html">hello</a> + <a class="code hl_class" href="class_vector__2d.html">world</a>;</div>
<div class="ttc" id="aclass_vector__2d_html"><div class="ttname"><a href="class_vector__2d.html">Vector_2d</a></div><div class="ttdef"><b>Definition</b> <a href="_vector__2d_8h_source.html#l00015">Vector_2d.h:15</a></div></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>String Iteration</b>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">char</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a> : <a class="code hl_class" href="class_vector__2d.html">greeting</a>) {</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">cout</a> &lt;&lt; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a>;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a1f2d7f8147412c43ba2303a56f97ee73"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a></div><div class="ttdeci">const GLubyte * c</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l13129">SDL_opengl_glext.h:13129</a></div></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Substrings and Searching</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <a class="code hl_class" href="class_vector__2d.html">pos</a> = <a class="code hl_class" href="class_vector__2d.html">greeting</a>.find(<span class="stringliteral">&quot;World&quot;</span>);</div>
<div class="line"><span class="keywordtype">string</span> sub = <a class="code hl_class" href="class_vector__2d.html">greeting</a>.substr(<a class="code hl_class" href="class_vector__2d.html">pos</a>, 5);</div>
</div><!-- fragment --></li>
<li><b>Conversion</b>: <div class="fragment"><div class="line"><span class="keywordtype">string</span> <a class="code hl_class" href="class_vector__2d.html">numStr</a> = <span class="stringliteral">&quot;12345&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a> = <a class="code hl_class" href="class_vector__2d.html">stoi</a>(<a class="code hl_class" href="class_vector__2d.html">numStr</a>);</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_abb50fc1ead3a02a46fb52daa2045f95c"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#abb50fc1ead3a02a46fb52daa2045f95c">num</a></div><div class="ttdeci">GLuint num</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l05929">SDL_opengl_glext.h:5929</a></div></div>
</div><!-- fragment --></li>
</ol>
<p>This overview covers most of the string class's capabilities in C++. However, the best way to fully understand and grasp its depth is to refer to the official documentation or a C++ reference and try out various methods and operations for yourself.</p>
<h1><a class="anchor" id="autotoc_md184"></a>
Explain the char and sting lateral in general</h1>
<p>Certainly! Let's delve into string literals and character literals in C++.</p>
<h2><a class="anchor" id="autotoc_md185"></a>
Character Literals:</h2>
<p>A character literal represents a single character and is enclosed in single quotes. In C++, a character literal has type <code>char</code>.</p>
<p>Examples:</p>
<ul>
<li>&lsquo;'a&rsquo;<code> -</code>'1'<code> -</code>''`</li>
</ul>
<p>There are also some special character literals called escape sequences:</p>
<ul>
<li>&lsquo;&rsquo;<br  />
'<code>: Newline -</code>'\t'<code>: Tab -</code>'\r'<code>: Carriage return -</code>'\''<code>: Single quote -</code>'"'<code>: Double quote -</code>'\0'<code>: Null character -</code>'<b></b>'`: Backspace</li>
</ul>
<h3><a class="anchor" id="autotoc_md186"></a>
Wide and Unicode Character Literals:</h3>
<ul>
<li><code>wchar_t</code> is used for wide character literals and is prefixed by <code>L</code>, e.g., &lsquo;L'Z&rsquo;<code>.</code></li>
<li><code>C++11 introduced</code>char16_t<code>for UTF-16 encoded characters with prefix</code>u<code>, e.g.,</code>u'Z'<code>and</code>char32_t<code>for UTF-32 encoded characters with prefix</code>U<code>, e.g.,</code>U'Z'`.</li>
</ul>
<h2><a class="anchor" id="autotoc_md187"></a>
String Literals:</h2>
<p>A string literal is a sequence of characters surrounded by double quotes. The compiler appends a null character (&lsquo;&rsquo;\0'`) to every string literal, making it a null-terminated string.</p>
<p>Examples:</p>
<ul>
<li><code>"Hello, World!"</code></li>
<li><code>"C++ Programming"</code></li>
<li><code>"12345"</code></li>
</ul>
<p>Similar to character literals, string literals also support escape sequences:</p>
<ul>
<li><code>"This is a string with a newline character.\n"</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md188"></a>
Raw String Literals:</h3>
<p>C++11 introduced raw string literals that allow you to write string literals without escaping characters. This is particularly useful for regex patterns, path specifications, or any multi-line string content. They are denoted by <code>R</code> and surrounded by <code>"( )"</code>.</p>
<p>Example:</p>
<ul>
<li><code>R"(This is a "raw" string. No need to escape the "double quotes".)"</code></li>
<li><code>R"(C:\Path\To\Directory)"</code> (notice no need to double backslash)</li>
</ul>
<h3><a class="anchor" id="autotoc_md189"></a>
Wide and Unicode String Literals:</h3>
<ul>
<li>Wide string literals use <code>wchar_t</code> and are prefixed by <code>L</code>, e.g., <code>L"Hello"</code>.</li>
<li>UTF-8 string literals (C++11) use <code>char</code> and are prefixed by <code>u8</code>, e.g., <code>u8"Hello"</code>.</li>
<li>UTF-16 string literals use <code>char16_t</code> and are prefixed by <code>u</code>, e.g., <code>u"Hello"</code>.</li>
<li>UTF-32 string literals use <code>char32_t</code> and are prefixed by <code>U</code>, e.g., <code>U"Hello"</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md190"></a>
Distinction Between String Literals and &lt;tt&gt;std::string&lt;/tt&gt;:</h2>
<p>It's crucial to understand that string literals (e.g., <code>"Hello"</code>) are of type <code>const char[]</code>. On the other hand, the <code>std::string</code> type from the C++ Standard Library is a class designed to handle strings, providing many utility functions. They can be implicitly converted, so you often see them being used interchangeably:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line">std::string str = <span class="stringliteral">&quot;This is a string literal assigned to a std::string object.&quot;</span>;</div>
</div><!-- fragment --><p>In the example above, the string literal <code>"This is a string literal assigned to a std::string object."</code> is automatically converted to a <code>std::string</code> object.</p>
<h1><a class="anchor" id="autotoc_md191"></a>
Types of string - Commonly used</h1>
<p>Extended table for <code>string</code> in <code>C++</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Type/Method</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Memory</b>   </th><th class="markdownTableHeadNone"><b>Mutable</b>   </th><th class="markdownTableHeadNone"><b>R/W</b>   </th><th class="markdownTableHeadNone"><b>Size Specified</b>   </th><th class="markdownTableHeadNone"><b>Example</b>   </th><th class="markdownTableHeadNone"><b>Usage &amp; Common Practices</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C-style array   </td><td class="markdownTableBodyNone">Fixed-size, contiguous block of memory.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>[N]</code>)   </td><td class="markdownTableBodyNone"><code>int arr[3] = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Prefer <code>std::array</code> or <code>std::vector</code> for safety and flexibility.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic C-style array   </td><td class="markdownTableBodyNone">Dynamically-allocated array.   </td><td class="markdownTableBodyNone">Heap   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (<code>[]</code>)   </td><td class="markdownTableBodyNone"><code>int* arr = new int[3]; arr[0] = 1;</code>   </td><td class="markdownTableBodyNone">Use with caution; must manually manage memory with <code>delete[]</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::array&lt;T, N&gt;</code>   </td><td class="markdownTableBodyNone">Fixed-size, stack-allocated.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>&lt;T, N&gt;</code>)   </td><td class="markdownTableBodyNone"><code>std::array&lt;int, 3&gt; arr = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Preferred over C-style array for fixed-size lists.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::vector&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Dynamic array with auto-resizing.   </td><td class="markdownTableBodyNone">Heap &amp; Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (at creation)   </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt; vec = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Most common dynamic list in C++; handles memory management.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::list&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Doubly-linked list.   </td><td class="markdownTableBodyNone">Heap   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">No (at creation)   </td><td class="markdownTableBodyNone"><code>std::list&lt;int&gt; lst = {1, 2, 3};</code>   </td><td class="markdownTableBodyNone">Use when frequent insertions/deletions are required in the middle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pointer to C-style array   </td><td class="markdownTableBodyNone">Points to the first element of an array.   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Depends   </td><td class="markdownTableBodyNone"><code>int nums[3] = {1, 2, 3}; int* p = nums;</code>   </td><td class="markdownTableBodyNone">Raw pointers can be error-prone; prefer modern alternatives.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Array of pointers   </td><td class="markdownTableBodyNone">Array where each element is a pointer.   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">R/W   </td><td class="markdownTableBodyNone">Yes (<code>[N]</code>)   </td><td class="markdownTableBodyNone"><code>int* arr[3]; for(int i=0; i&lt;3; i++) arr[i] = new int(i+1);</code>   </td><td class="markdownTableBodyNone">Use when needing an array of objects on the heap.   </td></tr>
</table>
<p><b>Notes:</b></p>
<ul>
<li><b>Size Specified</b>: This column indicates whether you must specify the size of the array/list at compile-time or not. For data structures where the size isn't specified at compile-time, it often means the size can be dynamically adjusted at runtime.</li>
<li><b>Memory Management</b>: As previously mentioned, always ensure to release any heap-allocated memory to prevent memory leaks.</li>
<li><b>Safety</b>: Using modern C++ containers is recommended for most use-cases due to their safety, flexibility, and the functionalities they provide.</li>
</ul>
<p><img src="../images/M01.jpg" alt="String in CPP" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md192"></a>
More details</h1>
<ul>
<li>I'll add a few more scenarios related to string handling in C++:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Type</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Define</b>   </th><th class="markdownTableHeadNone"><b>Read</b>   </th><th class="markdownTableHeadNone"><b>Write</b>   </th><th class="markdownTableHeadNone"><b>Allocation</b>   </th><th class="markdownTableHeadNone"><b>Null-Terminated</b>   </th><th class="markdownTableHeadNone"><b>Common Practices</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>String Literal</b>   </td><td class="markdownTableBodyNone">A sequence of characters surrounded by double quotes.   </td><td class="markdownTableBodyNone"><code>const char* str = "Hello";</code>   </td><td class="markdownTableBodyNone"><code>cout &lt;&lt; str;</code>   </td><td class="markdownTableBodyNone">N/A (immutable)   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Fixed messages, filenames, etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C-style String (char array)</b>   </td><td class="markdownTableBodyNone">Array of characters ending with a null terminator (&lsquo;&rsquo;\0'<code>). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char str[6] = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; str;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>str[0] = 'h';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Older C++ code; Prefer</code>std::string<code>in modern C++. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **</code>std::string<code>** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic string class in C++ standard library. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::string str = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; str;<code>or</code>str.c_str()<code>for C-style \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>str[0] = 'h'; str += " World";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap (usually) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; N/A \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Modern C++: safe and dynamic string handling. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **Pointer to C-style String** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Points to the first character of a C-style string. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>const char* ptr = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; ptr;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Not directly (points to a string literal) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes (if points to literal) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Be cautious with memory management. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **Array of C-style Strings** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Array with elements as pointers to C-style strings. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>const char* arr[] = {"Hello", "World"};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; arr[0];<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Not directly (contains string literals) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Older C++: be cautious with memory management. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **</code>std::vector&lt;std::string&gt;<code>** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic array of</code>std::string<code>objects. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::vector&lt;std::string&gt; vec = {"Hello", "World"};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; vec[0];<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>vec[0] = "HELLO"; <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">vec.push_back</a>("!");<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; N/A \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic list of strings in modern C++. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **Array of Characters** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Sequence of characters without null termination. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char arr[] = {'a', 'b'};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Using loops (not directly with</code>cout<code>) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>arr[0] = 'A';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; No \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Rare, since without null-termination it's not a proper string. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **Dynamic Array of Characters (heap)** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamically allocated array of characters. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char* arr = new char[3]{'a', 'b', '\0'};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; arr;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>arr[0] = 'A';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Depends on Initialization \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Requires</code>delete[]<code>for deallocation. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **String View (</code>std::string_view<code>)** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Non-owning reference to a string or a part of a string. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::string_view sv = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; sv;`   </td><td class="markdownTableBodyNone">N/A (non-modifiable)   </td><td class="markdownTableBodyNone">Depends on referred string   </td><td class="markdownTableBodyNone">Depends on referred string   </td><td class="markdownTableBodyNone">Used for efficient substring operations, available in C++17.   </td></tr>
</table>
<p><b>Additional Notes</b>:</p>
<ul>
<li>**<code>std::string_view</code>**: This is a lightweight, non-owning reference to a string. It doesn't allocate or deallocate memory, and it's useful when you want to work with substrings without copying. Always ensure that the underlying data outlives the <code>string_view</code> to avoid dangling references.</li>
</ul>
<p>This table should now provide a comprehensive overview of the different ways you can represent and work with strings in C++.</p>
<ul>
<li>The following ways are possible to create a string in CPP Sure! Here's a table illustrating the various ways to create and represent strings in C++:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Method</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Example</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>C-style (stack)</b>   </td><td class="markdownTableBodyNone">An array of characters on the stack. Needs manual null termination.   </td><td class="markdownTableBodyNone"><code>char str[] = "Hello";</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C-style (heap)</b>   </td><td class="markdownTableBodyNone">An array of characters on the heap. Needs manual null termination.   </td><td class="markdownTableBodyNone"><code>char* str = new char[6]; strcpy(str, "Hello");</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>std::string (stack)</b>   </td><td class="markdownTableBodyNone">C++ standard string class. Stored on the stack, manages memory.   </td><td class="markdownTableBodyNone"><code>std::string str = "Hello";</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>std::string (heap)</b>   </td><td class="markdownTableBodyNone">C++ standard string class. Object is allocated on the heap.   </td><td class="markdownTableBodyNone"><code>std::string* str = new std::string("Hello");</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>String Literal</b>   </td><td class="markdownTableBodyNone">Immutable sequence of characters. Stored in static memory region.   </td><td class="markdownTableBodyNone"><code>const char* str = "Hello";</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Raw String Literal</b>   </td><td class="markdownTableBodyNone">Allows for strings that span multiple lines or contain backslashes.   </td><td class="markdownTableBodyNone"><code>const char* str = R"(Hello\nWorld)";</code> (no escape needed)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>std::stringstream</b>   </td><td class="markdownTableBodyNone">Dynamic string stream. Useful for constructing strings from mixed types   </td><td class="markdownTableBodyNone"><code>std::stringstream ss; ss &lt;&lt; "Hello " &lt;&lt; 42;</code>   </td></tr>
</table>
<ul>
<li><b>C-style strings</b>: Are arrays of characters terminated by a null character (&lsquo;&rsquo;\0'`). They require manual memory management and can lead to buffer overflows if not handled correctly.</li>
<li><b>std::string</b>: A safer and more convenient way to work with strings in C++. It manages memory automatically and provides a range of useful string manipulation functions.</li>
<li><b>String Literal</b>: Is a sequence of characters between double quotes. They are stored in a static memory region, and thus, are immutable. Attempts to modify them result in undefined behavior.</li>
<li><b>Raw String Literal</b>: Provides a way to represent strings without escaping. Useful for representing paths, regex, or multi-line strings.</li>
<li><b>std::stringstream</b>: A stream-based way to construct and manipulate strings. Especially useful when combining different data types into a single string.</li>
<li>Always remember that for heap-allocated variables, it's necessary to release the memory using <code>delete</code> (or <code>delete[]</code> for arrays) to avoid memory leaks.</li>
</ul>
<h1><a class="anchor" id="autotoc_md193"></a>
String Array</h1>
<ul>
<li>Let's break down the ways you can work with strings and arrays of strings in C++, focusing on defining, reading, writing, and their common use cases:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Type</b>   </th><th class="markdownTableHeadNone"><b>Description</b>   </th><th class="markdownTableHeadNone"><b>Define</b>   </th><th class="markdownTableHeadNone"><b>Read</b>   </th><th class="markdownTableHeadNone"><b>Write</b>   </th><th class="markdownTableHeadNone"><b>Allocation</b>   </th><th class="markdownTableHeadNone"><b>Null-Terminated</b>   </th><th class="markdownTableHeadNone"><b>Common Practices</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>String Literal</b>   </td><td class="markdownTableBodyNone">A sequence of characters surrounded by double quotes.   </td><td class="markdownTableBodyNone"><code>const char* str = "Hello";</code>   </td><td class="markdownTableBodyNone"><code>cout &lt;&lt; str;</code>   </td><td class="markdownTableBodyNone">N/A (immutable)   </td><td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Fixed messages, filenames, etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>C-style String (char array)</b>   </td><td class="markdownTableBodyNone">Array of characters ending with a null terminator (&lsquo;&rsquo;\0'<code>). \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char str[6] = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; str;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>str[0] = 'h';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Older C++ code; Prefer</code>std::string<code>in modern C++. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **</code>std::string<code>** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic string class in C++ standard library. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::string str = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; str;<code>or</code>str.c_str()<code>for C-style \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>str[0] = 'h'; str += " World";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap (usually) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; N/A \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Modern C++: safe and dynamic string handling. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **Pointer to C-style String** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Points to the first character of a C-style string. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>const char* ptr = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; ptr;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Not directly (points to a string literal) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes (if points to literal) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Be cautious with memory management. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **Array of C-style Strings** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Array with elements as pointers to C-style strings. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>const char* arr[] = {"Hello", "World"};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; arr[0];<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Not directly (contains string literals) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Yes \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Older C++: be cautious with memory management. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **</code>std::vector&lt;std::string&gt;<code>** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic array of</code>std::string<code>objects. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::vector&lt;std::string&gt; vec = {"Hello", "World"};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; vec[0];<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>vec[0] = "HELLO"; <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">vec.push_back</a>("!");<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; N/A \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamic list of strings in modern C++. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **Array of Characters** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Sequence of characters without null termination. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char arr[] = {'a', 'b'};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Using loops (not directly with</code>cout<code>) \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>arr[0] = 'A';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Stack \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; No \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Rare, since without null-termination it's not a proper string. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowEven"&gt; &lt;td class="markdownTableBodyNone"&gt; **Dynamic Array of Characters (heap)** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Dynamically allocated array of characters. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>char* arr = new char[3]{'a', 'b', '\0'};<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; arr;<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>arr[0] = 'A';<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Heap \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Depends on Initialization \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Requires</code>delete[]<code>for deallocation. \ilinebr &lt;/td&gt; &lt;/tr&gt; &lt;tr class="markdownTableRowOdd"&gt; &lt;td class="markdownTableBodyNone"&gt; **String View (</code>std::string_view<code>)** \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt; Non-owning reference to a string or a part of a string. \ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>std::string_view sv = "Hello";<code>\ilinebr &lt;/td&gt; &lt;td class="markdownTableBodyNone"&gt;</code>cout &lt;&lt; sv;`   </td><td class="markdownTableBodyNone">N/A (non-modifiable)   </td><td class="markdownTableBodyNone">Depends on referred string   </td><td class="markdownTableBodyNone">Depends on referred string   </td><td class="markdownTableBodyNone">Used for efficient substring operations, available in C++17.   </td></tr>
</table>
<p><b>Notes</b>:</p>
<ul>
<li><b>String Literals</b> are immutable. Attempting to modify them results in undefined behavior.</li>
<li><b>C-style Strings</b> (<code>char</code> arrays) are error-prone due to manual memory management, lack of bounds checking, and susceptibility to buffer overflows.</li>
<li>**<code>std::string</code>** is dynamic and manages its memory. It can grow or shrink, and it's safer than C-style strings.</li>
<li>Always prefer <code>std::string</code> and <code>std::vector&lt;std::string&gt;</code> in modern C++ unless there's a specific need for C-style handling or interfacing with older APIs.</li>
</ul>
<p>Remember, regardless of how you're working with strings in C++, always be cautious about buffer overflows, memory leaks, and undefined behavior. Proper memory management is crucial, especially when working with raw pointers or C-style strings.</p>
<ul>
<li>Let's revise the table to include arrays of characters, allocation type (heap vs. stack), and whether or not the string is null-terminated:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span>* ptr = {<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>};  <span class="comment">// notice the single character is surrounded with quotes not double quotes.</span></div>
</div><!-- fragment --><p><b>Notes</b>:</p>
<ul>
<li><b>Allocation</b>: "Stack" denotes local/static storage duration, and "Heap" denotes dynamic storage duration.</li>
<li><b>Null-Termination</b>: Strings that aren't null-terminated (&lsquo;&rsquo;\0'<code>) can't be directly printed with</code>cout<code>without potential issues.</code></li>
<li><code>It's always essential to deallocate heap memory explicitly in C++ when using raw pointers.</code></li>
<li><code>Using</code>std::string<code>and</code>std::vector` abstracts away many of the complexities and pitfalls associated with raw pointers and arrays.</li>
</ul>
<p>Certainly, let's ensure the table is comprehensive. I'll add a few more scenarios related to string handling in C++:</p>
<p><b>Additional Notes</b>:</p>
<ul>
<li>**<code>std::string_view</code>**: This is a lightweight, non-owning reference to a string. It doesn't allocate or deallocate memory, and it's useful when you want to work with substrings without copying. Always ensure that the underlying data outlives the <code>string_view</code> to avoid dangling references.</li>
<li>This table should now provide a comprehensive overview of the different ways you can represent and work with strings in C++.</li>
</ul>
<h1><a class="anchor" id="autotoc_md194"></a>
Libraries dealing with string</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b><a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Boost.StringAlgo</a> &amp; <a class="el" href="class_vector__2d.html#a6d09fb691e01f179efcbef03bef13b9c">Boost.StringView</a></b>   </td><td class="markdownTableBodyNone">Part of the Boost library, they offer functions and classes for string manipulations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>ICU (International Components for Unicode)</b>   </td><td class="markdownTableBodyNone">A comprehensive library for Unicode support, text processing, regular expressions, and more.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>UTF8-CPP</b>   </td><td class="markdownTableBodyNone">Header-only library for encoding and decoding UTF-8 strings.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>fmt (previously cppformat/fmtlib)</b>   </td><td class="markdownTableBodyNone">Modern string formatting library, an alternative to printf and sprintf.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>RE2</b>   </td><td class="markdownTableBodyNone">Highly efficient, memory-safe regular expression library.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CTRE (Compile Time Regular Expressions)</b>   </td><td class="markdownTableBodyNone">Allows for regex matching at compile-time for potential performance benefits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>abseil (from Google)</b>   </td><td class="markdownTableBodyNone">Collection of C++ libraries with utilities for string operations among others.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md195"></a>
What is char* argv[] is there another way to declare this ?</h1>
<p>The expression <code>char* argv[]</code> is used in the main function of a C++ program to represent the command line arguments passed to the program. Here, <code>argv</code> is an array of pointers to <code>char</code>, where each pointer points to a null-terminated string (a C-style string). The size of the array is determined by the number of arguments passed to the program (including the program name itself).</p>
<p>The declaration <code>char* argv[]</code> can also be written as <code>char** argv</code>. These two declarations are equivalent in this context. Here's how:</p>
<ul>
<li><code>char* argv[]</code> is an array of <code>char</code> pointers.</li>
<li><code>char** argv</code> is a pointer to a <code>char</code> pointer, and it can also point to an array of <code>char</code> pointers.</li>
</ul>
<p>In both cases, <code>argv</code> can be indexed like an array to access the individual command-line arguments, and these arguments can be accessed as null-terminated strings. So, you can declare the main function with either of these equivalent forms:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a>, <span class="keywordtype">char</span>* argv[]) { <span class="comment">/* ... */</span> }</div>
<div class="ttc" id="a_c_make_c_x_x_compiler_id_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="_c_make_c_x_x_compiler_id_8cpp_source.html#l00830">CMakeCXXCompilerId.cpp:830</a></div></div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a>, <span class="keywordtype">char</span>** argv) { <span class="comment">/* ... */</span> }</div>
</div><!-- fragment --><p>In both cases, <code>argc</code> is the count of command-line arguments, and <code>argv</code> is an array of the arguments themselves as C-style strings.</p>
<h1><a class="anchor" id="autotoc_md196"></a>
Can you loop over these both show me an example ?</h1>
<p>Sure, here's an example of how you can loop over <code>argv</code> using either <code>char* argv[]</code> or <code>char** argv</code>. Both examples do exactly the same thing: they print each command-line argument on a separate line.</p>
<ol type="1">
<li>Using <code>char* argv[]</code>:</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a>, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_class" href="class_vector__2d.html">argc</a>; i++) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Argument &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Using <code>char** argv</code>:</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">argc</a>, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_class" href="class_vector__2d.html">argc</a>; i++) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Argument &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>In both cases, if you run the program with some command-line arguments, it will print each argument along with its position in the <code>argv</code> array.</li>
<li>The <code>argc</code> is the number of command-line arguments (including the name of the program itself as the first argument), and <code>argv</code> is an array of those arguments as C-style strings. This is why we can use a loop to go through each argument in the <code>argv</code> array, from <code>argv[0]</code> (which is the program name) to <code>argv[argc-1]</code> (which is the last command-line argument).</li>
</ul>
<h2><a class="anchor" id="autotoc_md197"></a>
More Examples</h2>
<p>Sure, here are several ways to create a string of characters in C++, including using C-style methods:</p>
<ol type="1">
<li>Using C++ Standard Library:</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line">std::string <a class="code hl_class" href="class_vector__2d.html">str1</a> = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line">std::string <a class="code hl_class" href="class_vector__2d.html">str2</a>(<span class="stringliteral">&quot;C++ Strings&quot;</span>);</div>
</div><!-- fragment --><ol type="1">
<li>Using C-style character array (null-terminated string):</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> <a class="code hl_class" href="class_vector__2d.html">cstr1</a>[] = <span class="stringliteral">&quot;Hello, C-style!&quot;</span>;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_class" href="class_vector__2d.html">cstr2</a>[12] = <span class="stringliteral">&quot;C-Strings&quot;</span>;</div>
</div><!-- fragment --><ol type="1">
<li>Using string concatenation:</li>
</ol>
<div class="fragment"><div class="line">std::string <a class="code hl_class" href="class_vector__2d.html">concat</a> = <a class="code hl_class" href="class_vector__2d.html">str1</a> + <span class="stringliteral">&quot; &quot;</span> + <a class="code hl_class" href="class_vector__2d.html">str2</a>;</div>
</div><!-- fragment --><ol type="1">
<li>Using C-style string functions:</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> <a class="code hl_class" href="class_vector__2d.html">cstr3</a>[50];</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">strcpy</a>(<a class="code hl_class" href="class_vector__2d.html">cstr3</a>, <span class="stringliteral">&quot;Copying C-string&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_class" href="class_vector__2d.html">cstr4</a>[50];</div>
<div class="line"><a class="code hl_class" href="class_vector__2d.html">sprintf</a>(<a class="code hl_class" href="class_vector__2d.html">cstr4</a>, <span class="stringliteral">&quot;Formatted %s&quot;</span>, <span class="stringliteral">&quot;C-string&quot;</span>);</div>
</div><!-- fragment --><ol type="1">
<li>Using string literals:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">str_literal</a> = <span class="stringliteral">&quot;String Literal&quot;</span>;</div>
</div><!-- fragment --><p>While C-style strings are familiar, they can be error-prone due to issues like buffer overflows. Using <code>std::string</code> from the C++ Standard Library is safer and more flexible.</p>
<h2><a class="anchor" id="autotoc_md198"></a>
More Examples</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function to modify and return the updated string</span></div>
<div class="line"><span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">appendText</a>(<span class="keywordtype">char</span>* <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">additional</a>) {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">inputLength</a> = <a class="code hl_class" href="class_vector__2d.html">strlen</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>);</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">additionalLength</a> = <a class="code hl_class" href="class_vector__2d.html">strlen</a>(<a class="code hl_class" href="class_vector__2d.html">additional</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a321ff419cd5252e54cf95e64dc6687ee">result</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code hl_class" href="class_vector__2d.html">inputLength</a> + <a class="code hl_class" href="class_vector__2d.html">additionalLength</a> + 1];</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">strcpy</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a321ff419cd5252e54cf95e64dc6687ee">result</a>, <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>);</div>
<div class="line">    <a class="code hl_class" href="class_vector__2d.html">strcat</a>(<a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a321ff419cd5252e54cf95e64dc6687ee">result</a>, <a class="code hl_class" href="class_vector__2d.html">additional</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#a321ff419cd5252e54cf95e64dc6687ee">result</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">initialText</a> = <span class="stringliteral">&quot;Hello, &quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">additionalText</a> = <span class="stringliteral">&quot;World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* <a class="code hl_class" href="class_vector__2d.html">updatedText</a> = <a class="code hl_class" href="class_vector__2d.html">appendText</a>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(<a class="code hl_class" href="class_vector__2d.html">initialText</a>), <a class="code hl_class" href="class_vector__2d.html">additionalText</a>);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">updatedText</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span>[] <a class="code hl_class" href="class_vector__2d.html">updatedText</a>; <span class="comment">// Don&#39;t forget to free the memory</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_a321ff419cd5252e54cf95e64dc6687ee"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#a321ff419cd5252e54cf95e64dc6687ee">result</a></div><div class="ttdeci">GLuint64EXT * result</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l11386">SDL_opengl_glext.h:11386</a></div></div>
<div class="ttc" id="a_s_d_l__opengl__glext_8h_html_ad3c78daa7d8673f71649d4840c641779"><div class="ttname"><a href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a></div><div class="ttdeci">GLenum GLenum GLenum input</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl__glext_8h_source.html#l11270">SDL_opengl_glext.h:11270</a></div></div>
</div><!-- fragment --><ul>
<li>Achieving the same thing using String class</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function to modify and return the updated string</span></div>
<div class="line">std::string <a class="code hl_class" href="class_vector__2d.html">appendText</a>(<span class="keyword">const</span> std::string&amp; <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, <span class="keyword">const</span> std::string&amp; <a class="code hl_class" href="class_vector__2d.html">additional</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_typedef" href="_s_d_l__opengl__glext_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a> + <a class="code hl_class" href="class_vector__2d.html">additional</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    std::string <a class="code hl_class" href="class_vector__2d.html">initialText</a> = <span class="stringliteral">&quot;Hello, &quot;</span>;</div>
<div class="line">    std::string <a class="code hl_class" href="class_vector__2d.html">additionalText</a> = <span class="stringliteral">&quot;World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code hl_class" href="class_vector__2d.html">updatedText</a> = <a class="code hl_class" href="class_vector__2d.html">appendText</a>(<a class="code hl_class" href="class_vector__2d.html">initialText</a>, <a class="code hl_class" href="class_vector__2d.html">additionalText</a>);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">updatedText</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md199"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line">std::string* <a class="code hl_class" href="class_vector__2d.html">myFunction</a>(std::string* <a class="code hl_class" href="class_vector__2d.html">my_str</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="_c_make_c_x_x_compiler_id_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="class_vector__2d.html">example</a>[5];</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a> = <span class="stringliteral">&quot;This is my string&quot;</span>;</div>
<div class="line">    std::string* ptr = &amp;<a class="code hl_typedef" href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;We are printing the array -&gt; [&quot;</span> &lt;&lt; <a class="code hl_class" href="class_vector__2d.html">example</a>[i] &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; *<a class="code hl_class" href="class_vector__2d.html">myFunction</a>(ptr) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::string* <a class="code hl_class" href="class_vector__2d.html">myFunction</a>(std::string* <a class="code hl_class" href="class_vector__2d.html">my_str</a>) {</div>
<div class="line">    *<a class="code hl_class" href="class_vector__2d.html">my_str</a> = *<a class="code hl_class" href="class_vector__2d.html">my_str</a> + <span class="stringliteral">&quot; -&gt; World!!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_class" href="class_vector__2d.html">my_str</a>;</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__opengl_8h_html_a4af680a6c683f88ed67b76f207f2e6e4"><div class="ttname"><a href="_s_d_l__opengl_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a></div><div class="ttdeci">GLdouble s</div><div class="ttdef"><b>Definition</b> <a href="_s_d_l__opengl_8h_source.html#l02063">SDL_opengl.h:2063</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
