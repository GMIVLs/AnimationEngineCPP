\chapter{Smart Pointers}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers}{}\label{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers}\index{Smart Pointers@{Smart Pointers}}
\label{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers_autotoc_md168}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers_autotoc_md168}%

\begin{DoxyItemize}
\item Here\textquotesingle{}s a table listing the smart pointers available in C++ and their typical use cases\+:
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Smart Pointer}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Smart Pointer}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}    }\\\cline{1-3}
\endhead
{\bfseries{std\+::unique\+\_\+ptr}}   &Owns a unique object, i.\+e., there can be only one {\ttfamily unique\+\_\+ptr} to the same object. Used when a single ownership model is appropriate. Automatically deletes the object when the {\ttfamily unique\+\_\+ptr} goes out of scope.   &{\ttfamily std\+::unique\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} p1(new int(42));} OR using {\ttfamily std\+::make\+\_\+unique}\+: {\ttfamily auto p1 = std\+::make\+\_\+unique\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}(42);}    \\\cline{1-3}
{\bfseries{std\+::shared\+\_\+ptr}}   &Owns a shared object; the object can be shared among multiple {\ttfamily shared\+\_\+ptr}s. Maintains a reference count, and deletes the object when the last {\ttfamily shared\+\_\+ptr} that owns it is destroyed or reset.   &{\ttfamily std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} p2(new int(42));} OR using {\ttfamily std\+::make\+\_\+shared}\+: {\ttfamily auto p2 = std\+::make\+\_\+shared\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}(42);}    \\\cline{1-3}
{\bfseries{std\+::weak\+\_\+ptr}}   &A companion to {\ttfamily shared\+\_\+ptr}, doesn\textquotesingle{}t change the reference count. Useful in situations where you want to prevent circular references among {\ttfamily shared\+\_\+ptr}s. When you need to access the object, it can be converted to a {\ttfamily shared\+\_\+ptr}.   &{\ttfamily std\+::weak\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} wp = p2;} (Assuming {\ttfamily p2} is a {\ttfamily shared\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}})    \\\cline{1-3}
{\bfseries{std\+::auto\+\_\+ptr}}   &Deprecated in C++11 and removed in C++17. Was a precursor to {\ttfamily unique\+\_\+ptr} but had some issues (e.\+g., unclear ownership transfers). Avoid using.   &{\ttfamily std\+::auto\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} p3(new int(42));} (Not recommended)   \\\cline{1-3}
\end{longtabu}


{\bfseries{Notes\+:}}


\begin{DoxyItemize}
\item {\bfseries{std\+::unique\+\_\+ptr}}\+: Ensures a single unique ownership, which means the object can be owned by only one {\ttfamily unique\+\_\+ptr} at a time. This makes it efficient and lightweight.
\item {\bfseries{std\+::shared\+\_\+ptr}}\+: Maintains reference counting, making it heavier than {\ttfamily unique\+\_\+ptr}. Use it only when multiple ownership is genuinely required.
\item {\bfseries{std\+::weak\+\_\+ptr}}\+: Doesn\textquotesingle{}t own the object, so it doesn\textquotesingle{}t affect the reference count of a shared object. It\textquotesingle{}s mainly used to break circular references among {\ttfamily shared\+\_\+ptr}s.
\item {\bfseries{std\+::auto\+\_\+ptr}}\+: Deprecated and should not be used in new code. It was the first attempt to provide automatic memory management, but had semantic issues especially during copy and assignment.
\end{DoxyItemize}

When possible, prefer using the {\ttfamily std\+::make\+\_\+unique} and {\ttfamily std\+::make\+\_\+shared} helper functions to create smart pointers, as they are safer and can provide better performance due to optimizations.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers_autotoc_md169}{}\doxysection{\texorpdfstring{More Details}{More Details}}\label{md_docs_2own__docs_2cpp__fudamentals_2smart_pointers_autotoc_md169}
In C++, there are three types of smart pointers\+:


\begin{DoxyEnumerate}
\item {\bfseries{std\+::unique\+\_\+ptr}}\+: This represents exclusive ownership of an object. A {\ttfamily unique\+\_\+ptr} cannot be copied, which means there can be at most one {\ttfamily unique\+\_\+ptr} pointing to an object at a time. When the {\ttfamily unique\+\_\+ptr} is destroyed, the object it points to is automatically destroyed as well. This is useful when you want to ensure that an object is deleted when it is no longer needed.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::unique\_ptr<int>\ ptr(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(5));\ \textcolor{comment}{//\ create\ a\ unique\_ptr}}
\DoxyCodeLine{\textcolor{comment}{//\ Or}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ ptr\ =\ std::make\_unique<int>(5);\ \textcolor{comment}{//\ create\ a\ unique\_ptr\ using\ std::make\_unique\ (preferred\ way)}}

\end{DoxyCode}

\item {\bfseries{std\+::shared\+\_\+ptr}}\+: This represents shared ownership of an object. Multiple {\ttfamily shared\+\_\+ptr} instances can point to the same object, and the object will only be destroyed when the last {\ttfamily shared\+\_\+ptr} pointing to it is destroyed. This is useful when you want to share an object between multiple parts of your program.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::shared\_ptr<int>\ \mbox{\hyperlink{class_vector__2d}{ptr1}}(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(5));\ \textcolor{comment}{//\ create\ a\ shared\_ptr}}
\DoxyCodeLine{std::shared\_ptr<int>\ \mbox{\hyperlink{class_vector__2d}{ptr2}}\ =\ \mbox{\hyperlink{class_vector__2d}{ptr1}};\ \textcolor{comment}{//\ both\ ptr1\ and\ ptr2\ now\ point\ to\ the\ same\ object}}
\DoxyCodeLine{\textcolor{comment}{//\ Or}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ ptr\ =\ std::make\_shared<int>(5);\ \textcolor{comment}{//\ create\ a\ shared\_ptr\ using\ std::make\_shared\ (preferred\ way)}}

\end{DoxyCode}

\item {\bfseries{std\+::weak\+\_\+ptr}}\+: This is a weak reference to an object that is owned by a {\ttfamily shared\+\_\+ptr}. A {\ttfamily weak\+\_\+ptr} doesn\textquotesingle{}t contribute to the reference count of a {\ttfamily shared\+\_\+ptr}. This means it doesn\textquotesingle{}t prevent the object from being destroyed. You can use it to break cycles in data structures that could cause memory leaks with {\ttfamily shared\+\_\+ptr}.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::shared\_ptr<int>\ ptr(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(5));\ \textcolor{comment}{//\ create\ a\ shared\_ptr}}
\DoxyCodeLine{std::weak\_ptr<int>\ \mbox{\hyperlink{class_vector__2d}{weakPtr}}\ =\ ptr;\ \textcolor{comment}{//\ create\ a\ weak\_ptr\ from\ a\ shared\_ptr}}
\DoxyCodeLine{\textcolor{comment}{//\ The\ object\ ptr\ points\ to\ is\ still\ destroyed\ when\ ptr\ is\ destroyed,\ despite\ weakPtr\ still\ existing}}

\end{DoxyCode}

\end{DoxyEnumerate}

These smart pointers are a part of the C++ Standard Library and can help manage resources, reduce memory leaks, and improve code readability and safety. It\textquotesingle{}s generally recommended to use smart pointers over raw pointers when you can. 