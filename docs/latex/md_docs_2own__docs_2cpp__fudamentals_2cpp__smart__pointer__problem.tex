\chapter{\texorpdfstring{$<$}{<}em\texorpdfstring{$>$}{>}Smart Pointers\texorpdfstring{$<$}{<}/em\texorpdfstring{$>$}{>}}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem}{}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem}\index{$<$em$>$Smart Pointers$<$/em$>$@{$<$em$>$Smart Pointers$<$/em$>$}}
\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem_autotoc_md82}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem_autotoc_md82}%
Let me know if this ever happend to you, that you feel like finally \+\_\+\+\_\+\+\_\+mastered pointers\+\_\+\+\_\+\+\_\+ write some code that uses pointers maybe you use \+\_\+\+\_\+\+\_\+the heap\+\_\+\+\_\+\+\_\+ may you don\textquotesingle{}t, run your code and it still crashes anyways you check the syntax of your code and the syntax is definitely right but something about the code isn\textquotesingle{}t, now all because you know how to use pointers \+\_\+\+\_\+\+\_\+doesn\textquotesingle{}t mean you\textquotesingle{}re using them correctly\+\_\+\+\_\+\+\_\+ and it\textquotesingle{}s actually really easy to mess up raw pointers in \+\_\+\+\_\+\+\_\+C and C++\+\_\+\+\_\+\+\_\+ take for example this piece of code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ \mbox{\hyperlink{class_vector__2d}{line}}[128];}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{while}(1)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{printf}}(\textcolor{stringliteral}{"{}[auth\ =\ \%p,\ service\ =\ \%p]\(\backslash\)n"{}},\ \mbox{\hyperlink{class_vector__2d}{auth}},\ \mbox{\hyperlink{class_vector__2d}{service}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{fgets}}(\mbox{\hyperlink{class_vector__2d}{line}},\ \textcolor{keyword}{sizeof}(\mbox{\hyperlink{class_vector__2d}{line}}),\ \mbox{\hyperlink{class_vector__2d}{stdin}})\ =\ \mbox{\hyperlink{begin__code_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}})\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{strncmp}}(\mbox{\hyperlink{class_vector__2d}{line}},\ \textcolor{stringliteral}{"{}auth"{}},\ 5)\ =\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{auth}}\ =\ \mbox{\hyperlink{class_vector__2d}{malloc}}(\textcolor{keyword}{sizeof}(\mbox{\hyperlink{class_vector__2d}{auth}}));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{memset}}(\mbox{\hyperlink{class_vector__2d}{auth}},\ 0,\ \textcolor{keyword}{sizeof}(\mbox{\hyperlink{class_vector__2d}{auth}}));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{strlen}}(\mbox{\hyperlink{class_vector__2d}{line}}\ +\ 5)\ <\ 31)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{strcpy}}(\mbox{\hyperlink{class_vector__2d}{auth}}-\/>name,\ \mbox{\hyperlink{class_vector__2d}{line}}\ +\ 5);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{strncmp}}(\mbox{\hyperlink{class_vector__2d}{line}},\ \textcolor{stringliteral}{"{}reset"{}},\ 5)\ =\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{free}}(\mbox{\hyperlink{class_vector__2d}{auth}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{strncmp}}(\mbox{\hyperlink{class_vector__2d}{line}},\ \textcolor{stringliteral}{"{}service"{}},\ 6)\ =\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{service}}\ =\ \mbox{\hyperlink{class_vector__2d}{strdup}}(\mbox{\hyperlink{class_vector__2d}{line}}\ +\ 7);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{strncmp}}(\mbox{\hyperlink{class_vector__2d}{line}},\ \textcolor{stringliteral}{"{}login"{}},\ 5)\ =\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{auth}}-\/>auth)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{printf}}(\textcolor{stringliteral}{"{}you\ have\ logged\ in\ already!\(\backslash\)n"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{class_vector__2d}{printf}}(\textcolor{stringliteral}{"{}please\ enter\ your\ password\(\backslash\)n"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 Here, you see the bug. This bug has a used after free vulnerability where on this line here the code gets freed\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\mbox{\hyperlink{class_vector__2d}{free}}(\mbox{\hyperlink{class_vector__2d}{auth}});}

\end{DoxyCode}
 but later on the logic doesn\textquotesingle{}t check for the free and the pointer gets used anyway causing the program to crash. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordflow}{if}(\mbox{\hyperlink{class_vector__2d}{auth}}-\/>auth)}

\end{DoxyCode}
 I used the syntax correctly, I just didn\textquotesingle{}t use \+\_\+\+\_\+\+\_\+the pointers correctly\+\_\+\+\_\+\+\_\+ now I know C++ catches a lot of hate for being a language that kind of puts the whole kitchen sink into the language but it actually has some really elegant solutions for stopping this kind of scenario from happening in the future by using thing called \+\_\+\+\_\+\+\_\+"{}\+SMART POINTERS"{}\+\_\+\+\_\+\+\_\+ that add some really cool functionality but also have some really huge pitfalls that make using pointers easy in some places and harder in others.

Let\textquotesingle{}s talk about those scenarios, now here is an example of C++ code where we create an example class, the class\textquotesingle{}s name is dog and it has a method speak and a method that\textquotesingle{}s a Setter of set name that sets the dog\textquotesingle{}s name. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <cstring>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{class_vector__2d}{Dog}}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{speak}}();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{setName}}(std::string);}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::string\ \mbox{\hyperlink{_s_d_l__opengl__glext_8h_a8e1a4ccadfc12dbf9a8e411d68adfe8e}{name}};}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{Dog::setName}}(std::string\ \mbox{\hyperlink{_s_d_l__opengl__glext_8h_ad3c78daa7d8673f71649d4840c641779}{input}})\ \{}
\DoxyCodeLine{\ \ \ \ this-\/>\mbox{\hyperlink{_s_d_l__opengl__glext_8h_a8e1a4ccadfc12dbf9a8e411d68adfe8e}{name}}\ =\ \mbox{\hyperlink{_s_d_l__opengl__glext_8h_ad3c78daa7d8673f71649d4840c641779}{input}};}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{Dog::speak}}()\ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}bork\ bork\ i\ am\ "{}}\ <<\ this-\/>\mbox{\hyperlink{_s_d_l__opengl__glext_8h_a8e1a4ccadfc12dbf9a8e411d68adfe8e}{name}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{Dog}}\ *\mbox{\hyperlink{class_vector__2d}{d}})\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>setName(\textcolor{stringliteral}{"{}highhigh"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{Dog}}\ *\mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ \textcolor{keyword}{new}\ \mbox{\hyperlink{class_vector__2d}{Dog}}();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{ralf}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>setName(\textcolor{stringliteral}{"{}asdfasdf"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>speak();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 We have the functions defined here reset the name and then when we talk we say \+\_\+\+\_\+\+\_\+bork bork\+\_\+\+\_\+\+\_\+ I\textquotesingle{}m the dog, um and so this is the example that people typically show to show why you should \+\_\+\+\_\+\+\_\+never use raw pointers in C++\+\_\+\+\_\+\+\_\+ so we create a new dog and set the dog pointer named {\bfseries{Ralph}} and then later we call the function \+\_\+\+\_\+\+\_\+do\+\_\+something\+\_\+with\+\_\+the\+\_\+dog\+\_\+\+\_\+\+\_\+ where we say the pass object set it\textquotesingle{}s name to "{}high high"{} and then speak so if we go ahead and compile it and run it, it actually behaves as expected no issues so far, but what if there was logic in this code where we do something to the dog and eventually we say delete \+\_\+\+\_\+\+\_\+d\+\_\+\+\_\+\+\_\+ 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{Dog}}\ *\mbox{\hyperlink{class_vector__2d}{d}})\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>setName(\textcolor{stringliteral}{"{}highhigh"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{delete}(\mbox{\hyperlink{class_vector__2d}{d}});}
\DoxyCodeLine{\}}

\end{DoxyCode}
 but later on in the code when we talk about the dog or do something else with it outside of that function we don\textquotesingle{}t check the value of the pointer to see if it\textquotesingle{}s \+\_\+\+\_\+\+\_\+\+NULL\+\_\+\+\_\+\+\_\+ or freed and then eventually we run into a crashing state right where we could say bork bork I am high high this first part run but later on in the program because this pointer Ralph is no longer valid it crashes the program. Instead of using a raw pointer in C++, we can use the smart pointer concept. Here we\textquotesingle{}re going to create what is called a \+\_\+\+\_\+\+\_\+unique pointer\+\_\+\+\_\+\+\_\+ 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ std::make\_unique<Dog>();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{ralf}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>setName(\textcolor{stringliteral}{"{}asdfasdf"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>speak();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \+\_\+\+\_\+\+\_\+\+Unique pointer,\+\_\+\+\_\+\+\_\+ literally is as it sounds a pointer to an object that is unique meaning no one else is allowed to point to that object we make a unique pointer of a type dog with pointer name ralf and then we call standard make unique on dog to invoke the object constructor and make the object right and then we can just pass the ralf pointer like a regular pointer we can call set name on it and speak, and we can compile and run it. We get kind of that expected behavior right bork bork I am asdfasdf, now the things start to get a little weird with unique pointers and you start trying to use it in other places in your program, it\textquotesingle{}s represents not only a pointer that is unique to an object that points to that object, but it also represents \+\_\+\+\_\+\+\_\+who owns that object\+\_\+\+\_\+\+\_\+ and in programming when we say who owns a thing we\textquotesingle{}re talking about \+\_\+\+\_\+\+\_\+whow was responsible for destroying the \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{object.\+\_\+\+\_\+\+\_\+} when you\textquotesingle{}re done using it right to prevent that use after free scenario and to prevent memory leaks right now as programmed by passing in ralf which is a unique to a function that expects a dog pointer a raw C pointer as input we will get a pretty nasty compilation error because these types just don\textquotesingle{}t match up so by now changing the parameter type from a dog raw pointer to a unique pointer. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{d}})\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>setName(\textcolor{stringliteral}{"{}highhigh"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\}}

\end{DoxyCode}
 Would you think that this would work but this is also another problem and it goes against the unique pointer constrcut, if we compile this what\textquotesingle{}s happening here actually passing the value of the unique pointer ralf by value right we are making a copy of the unique pointer and that in itself is not very unique right. I\textquotesingle{}m now at the same time have two copies of the same pointer and the C++ compiler will not allow me to do that to pass ownership of the object from our main function to do something with the dog function. We have to do what is called move we will literally standard move ralf the dog to this function and now this function is responsible for controlling it so if we compile that we get no errors\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ std::make\_unique<Dog>();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(std::move(\mbox{\hyperlink{class_vector__2d}{ralf}}));}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>setName(\textcolor{stringliteral}{"{}asdfasdf"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 but when we run this we did crash again and I want to see if you guys understand why we crashed?? As I saied before ownership is the idea of who is responsible for destroying the object we moved ownership of ralf to our function do something with the doe then we called set\+Name on ralf and called speak also, and because we did not return ralf object it went out of scope so that C++ smart pointer freed ralf from our code then continued and later on in the code we tried to use function in an object that had been freed and we crashed the program just like befor. This first part pointer started to get a little weird right because now essentially every time I want to use a smart pointer I have to say that this is no longer a void function this is a standard unique pointer to a dog, and we\textquotesingle{}re going to say that it returns this and we\textquotesingle{}re going to say that it return d, and we\textquotesingle{}ll say that ralf now equals itself after the move so it does something with the dog what we move ralf into we pull ralf back out and now the program doesn\textquotesingle{}t crash. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{d}})\ \{\ \textcolor{comment}{//\ here}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>setName(\textcolor{stringliteral}{"{}highhigh"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}(\mbox{\hyperlink{class_vector__2d}{d}});\ \textcolor{comment}{//\ here\ is\ the\ change}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 and change the main function\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::unique\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ std::make\_unique<Dog>();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(std::move(\mbox{\hyperlink{class_vector__2d}{ralf}}));\ \textcolor{comment}{//\ here\ is\ the\ change}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ also\ can\ use\ the\ get()\ method}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ do\_something\_with\_the\_dog(ralf.get());}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>setName(\textcolor{stringliteral}{"{}asdfasdf"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 It runs twice but this is kind of gross right this code is not very good to look at it\textquotesingle{}s kind of counfusing and typically when you have a function that does something you want to return the result of the thing but if I have to move ralf out of the function every time now every time I want to use a unique pointer it makes it very ugly to do so one way we can deal with this problem with the unique pointer where we have to pass it around and move it and then unmoves it is to use the get method from the unique pointer so the get method in the unique pointer actually returns a raw pointer to the thing that the unique pointer controls. You\textquotesingle{}re probably thinking well then doesn\textquotesingle{}t that defeat the entire purpose of the unique pointer and yes it does but what you can do with it, actually there\textquotesingle{}s a couple ways you can work around it to make the unique raw pointer work right so here i say ralf get which again returns the raw pointer to ralf what we can do is in our function that uses that raw pointer we can set the raw pointer to a constant which essentially locks down what the pointer is able to do and it doesn\textquotesingle{}t allow us to modify our class variable now that adds some future complications where now dog speak has to be declared as a const function that guarantees we don\textquotesingle{}t actully modify the class we have to also put that in the declaration right here but with that all done we can go ahead and compile thsi and eventually we can actually use the raw pointer to do certian things with the class while also retaining ownership in the main function now an even easier way to do this is just to treat this that way. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{Dog}}\ *\mbox{\hyperlink{class_vector__2d}{d}})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\}}

\end{DoxyCode}
 I think you should treat it all the time generally which is the use of the other class call a \+\_\+\+\_\+\+\_\+shared pointer (std\+::shared\+\_\+ptr$<$\+Type$>$)\+\_\+\+\_\+\+\_\+ so if you have a shared pointer dog d it\textquotesingle{}s a still a void we\textquotesingle{}ll clean up our constants here and then we will also say d set\+Name to asked as this will be not a unique it\textquotesingle{}ll be a make shared and will set this to a shared pointer and then we will just pass ralf and that should work. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(std::shared\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{d}})\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>setName(\textcolor{stringliteral}{"{}hihihihi"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{d}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{comment}{//\ and\ should\ use\ std::shared\_ptr\ in\ main\ function}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{class_vector__2d}{argc}},\ \textcolor{keywordtype}{char}\ **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<Dog>\ \mbox{\hyperlink{class_vector__2d}{ralf}}\ =\ std::make\_shared<Dog>();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{do\_something\_with\_the\_dog}}(\mbox{\hyperlink{class_vector__2d}{ralf}});\ \textcolor{comment}{//\ here\ is\ the\ change}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>setName(\textcolor{stringliteral}{"{}asdfasdf"{}});}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{ralf}}-\/>speak();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 What happens here is we essentially create a shared pointer which is a unique pointer that can have multiple copies of itself as we create the second copy of ralf all that happens is that the reference counter inside the shared pointer goes up by one and that reference counter is used here to denote that we have a pointer that now has two places that are using it when d goes out of scope the shared pointer copy that we made is deleted and we still retain ownership of the object here in main then ralf continues and we call the extra functions here and things are good.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem_autotoc_md83}{}\doxysection{\texorpdfstring{$<$em$>$\+REFERENCES$<$/em$>$}{<em>REFERENCES</em>}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__smart__pointer__problem_autotoc_md83}

\begin{DoxyEnumerate}
\item \href{https://www.youtube.com/watch?v=tSIBKys2eBQ}{\texttt{ youtube}} 
\end{DoxyEnumerate}