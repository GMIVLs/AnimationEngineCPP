\chapter{Moving Semantics}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2moving__semantics}{}\label{md_docs_2own__docs_2cpp__fudamentals_2moving__semantics}\index{Moving Semantics@{Moving Semantics}}
\label{md_docs_2own__docs_2cpp__fudamentals_2moving__semantics_autotoc_md136}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2moving__semantics_autotoc_md136}%
 Move semantics, introduced in C++11, is a way to transfer resources from one object to another without the overhead of deep copying. The main mechanism behind move semantics is the rvalue reference ({\ttfamily T\&\&}). Here\textquotesingle{}s a table explaining its various usages and related concepts\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Concept}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Concept}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}    }\\\cline{1-4}
\endhead
{\bfseries{Move Constructor}}   &Constructs an object by acquiring the resources of another object rather than copying them.   &{\ttfamily cpp class My\+Class \{ public\+: My\+Class(My\+Class\&\& other) \{...\} \};}   &Creating a new object by transferring resources from a temporary.    \\\cline{1-4}
{\bfseries{Move Assignment Operator}}   &Assigns resources from one object to another by moving instead of copying.   &{\ttfamily cpp class My\+Class \{ public\+: My\+Class\& operator=(My\+Class\&\& other) \{...\} \};}   &Transferring resources between existing objects.    \\\cline{1-4}
{\ttfamily std\+::move()}   &Casts an object to an rvalue reference, enabling move semantics.   &{\ttfamily cpp My\+Class obj1; My\+Class obj2 = std\+::move(obj1);}   &Explicitly signaling that an object\textquotesingle{}s resources can be transferred.    \\\cline{1-4}
{\bfseries{Rvalue Reference}}   &A type of reference that can bind to temporary objects.   &{\ttfamily cpp void foo(My\+Class\&\& obj) \{...\}}   &Function overloading based on whether an argument is a temporary.    \\\cline{1-4}
{\ttfamily std\+::forward\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}()}   &Perfect forwarding utility to pass an argument as either lvalue or rvalue based on its original type.   &{\ttfamily cpp template\texorpdfstring{$<$}{<}typename T\texorpdfstring{$>$}{>} void wrapper(T\&\& arg) \{ foo(std\+::forward\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(arg)); \}}   &Forwarding arguments in template functions without changing their value category.   \\\cline{1-4}
\end{longtabu}


{\bfseries{Notes}}\+:


\begin{DoxyEnumerate}
\item {\bfseries{Destructive Transfer}}\+: When performing a move operation, it\textquotesingle{}s common practice to leave the moved-\/from object in a valid but unspecified state. For example, if you\textquotesingle{}re moving from a dynamic array, you might set the source object\textquotesingle{}s pointer to {\ttfamily nullptr} after the move.
\item {\bfseries{Move vs. Copy}}\+: If an object supports both move and copy semantics, move operations are preferred when working with rvalues (like temporaries), while copy operations are used with lvalues.
\item {\bfseries{Perfect Forwarding}}\+: Perfect forwarding with {\ttfamily std\+::forward\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}()} allows a function template to forward an argument to another function while retaining the argument\textquotesingle{}s original lvalue/rvalue nature.
\item {\bfseries{Automatic Move}}\+: In many cases, the compiler can automatically use move semantics to eliminate unnecessary deep copies, especially with return values or when throwing exceptions.
\end{DoxyEnumerate}

Using move semantics can significantly improve performance, especially for objects that manage heavy resources, like dynamic memory, file handles, or network sockets. 