\chapter{Run time vs Complie time}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2runtime__vs__complietime}{}\label{md_docs_2own__docs_2cpp__fudamentals_2runtime__vs__complietime}\index{Run time vs Complie time@{Run time vs Complie time}}
\label{md_docs_2own__docs_2cpp__fudamentals_2runtime__vs__complietime_autotoc_md167}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2runtime__vs__complietime_autotoc_md167}%

\begin{DoxyItemize}
\item Understanding the distinction between compile-\/time and run-\/time in C++ is crucial. Here\textquotesingle{}s a table illustrating these concepts\+:
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Concept}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Time}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Code Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practices}}    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Concept}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Time}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Code Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practices}}    }\\\cline{1-6}
\endhead
{\bfseries{Literal Constants}}   &Compile-\/time   &Values known at compile-\/time.   &{\ttfamily const int x = 10;}   &Setting fixed values or configurations.   &Avoid magic numbers; use named constants.    \\\cline{1-6}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}{\ttfamily constexpr}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   &Compile-\/time   &Enables the definition of constants or functions whose values/results are computable at compile-\/time.   &{\ttfamily constexpr int square(int x) \{ return x\texorpdfstring{$\ast$}{*}x; \}}   &Performance optimizations, array sizes.   &Use {\ttfamily constexpr} to enforce compile-\/time evaluation.    \\\cline{1-6}
{\bfseries{Templates}}   &Compile-\/time   &Mechanism to write generic code. Types are deduced at compile-\/time.   &{\ttfamily template\texorpdfstring{$<$}{<}typename T\texorpdfstring{$>$}{>} T max(\+T a, T b) \{ ... \}}   &Generic programming, STL containers/functions.   &Ensure broad template type applicability.    \\\cline{1-6}
{\bfseries{Static Memory Allocation}}   &Compile-\/time   &Fixed-\/size memory allocation, typically on the stack. Size must be known at compile time.   &{\ttfamily int arr\mbox{[}10\mbox{]};}   &Local variables, class members.   &Monitor stack usage to prevent overflow.    \\\cline{1-6}
{\bfseries{Static Assertions}}   &Compile-\/time   &Asserts conditions during compilation.   &{\ttfamily static\+\_\+assert(sizeof(int) == 4, "{}\+Int size is not 4 bytes!"{});}   &Ensuring platform/code assumptions.   &Use to catch violations of assumptions early.    \\\cline{1-6}
{\bfseries{Dynamic Memory Allocation}}   &Run-\/time   &Memory allocation determined at run-\/time, typically on the heap.   &{\ttfamily int\texorpdfstring{$\ast$}{*} arr = new int\mbox{[}size\mbox{]};}   &Flexible data structures, long-\/lived objects.   &Pair {\ttfamily new} with {\ttfamily delete}; prefer smart pointers.    \\\cline{1-6}
{\bfseries{Function Calls}}   &Run-\/time   &Execution of function logic occurs during run-\/time, unless inlined or evaluated at compile-\/time via {\ttfamily constexpr}.   &{\ttfamily int y = square(x);}   &Most of the program\textquotesingle{}s logic.   &Use function calls to modularize code.    \\\cline{1-6}
{\bfseries{I/O Operations}}   &Run-\/time   &Interactions with external systems, like reading/writing files or console operations.   &{\ttfamily std\+::cin \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} x; std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} x;}   &User input/output, file handling.   &Error handling and validation for I/O operations.    \\\cline{1-6}
{\bfseries{Variable Values}}   &Run-\/time   &Value of a variable (unless {\ttfamily constexpr}) which might be determined at run-\/time.   &{\ttfamily int x; std\+::cin \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} x;}   &Almost everywhere in the program.   &Always initialize variables.    \\\cline{1-6}
{\bfseries{Pointers and References}}   &Run-\/time   &Pointing or referring to memory locations which might be determined at run-\/time.   &{\ttfamily int\texorpdfstring{$\ast$}{*} p = \&x;}   &Dynamic data structures, polymorphism.   &Avoid dangling pointers/references.    \\\cline{1-6}
{\bfseries{Dynamic Type Checking}}   &Run-\/time   &Checking type at run-\/time, often in polymorphism scenarios.   &{\ttfamily if (auto derived = dynamic\+\_\+cast\texorpdfstring{$<$}{<}Derived\texorpdfstring{$\ast$}{*}\texorpdfstring{$>$}{>}(base\+Ptr)) \{ ... \}}   &Inheritance hierarchies, polymorphic calls.   &Use sparingly; prefer static (compile-\/time) type checking.   \\\cline{1-6}
\end{longtabu}


{\bfseries{General Notes}}\+:


\begin{DoxyItemize}
\item Compile-\/time operations are determined when the code is compiled. They can help optimize performance since decisions and evaluations are made upfront.
\item Run-\/time operations happen when the program is executed. These offer flexibility but can introduce overhead.
\item Modern C++ (C++11 and beyond) introduces more compile-\/time features (like {\ttfamily constexpr}) to help with optimization.
\item Be conscious of the trade-\/offs between compile-\/time and run-\/time choices, especially in performance-\/critical applications. 
\end{DoxyItemize}