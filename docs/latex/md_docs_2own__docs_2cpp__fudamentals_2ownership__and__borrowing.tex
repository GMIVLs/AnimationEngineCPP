\chapter{Owner\+Ship and Borrowing}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2ownership__and__borrowing}{}\label{md_docs_2own__docs_2cpp__fudamentals_2ownership__and__borrowing}\index{OwnerShip and Borrowing@{OwnerShip and Borrowing}}
\label{md_docs_2own__docs_2cpp__fudamentals_2ownership__and__borrowing_autotoc_md152}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2ownership__and__borrowing_autotoc_md152}%

\begin{DoxyItemize}
\item Certainly, understanding ownership in C++ is vital to prevent memory leaks and ensure proper resource management. Here\textquotesingle{}s a table detailing the primary ownership models in C++\+:
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Ownership Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Code Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practices}}    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Ownership Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Code Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Common Usages}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practices}}    }\\\cline{1-5}
\endhead
{\bfseries{Raw Pointer}}   &Traditional C++ pointers that can point to allocated memory but don\textquotesingle{}t manage the memory\textquotesingle{}s lifecycle.   &{\ttfamily int\texorpdfstring{$\ast$}{*} p = new int(5);}   &Older C++ code; low-\/level programming.   &Always pair {\ttfamily new} with {\ttfamily delete}; avoid manual memory management in high-\/level code.    \\\cline{1-5}
{\bfseries{Stack Ownership}}   &Variables created on the stack are automatically destroyed when they go out of scope.   &{\ttfamily int i = 5;}   &Local variables, small objects.   &Prefer stack allocation for small objects and primitives.    \\\cline{1-5}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Unique Ownership ({\ttfamily std\+::unique\+\_\+ptr})\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   &Smart pointer that owns a dynamically allocated object exclusively. The object is deleted automatically when the {\ttfamily unique\+\_\+ptr} is destroyed.   &{\ttfamily std\+::unique\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} p = std\+::make\+\_\+unique\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}(5);}   &When only one owner should manage the object\textquotesingle{}s lifecycle.   &Prefer {\ttfamily std\+::make\+\_\+unique} to create a {\ttfamily unique\+\_\+ptr}. Avoid raw pointer use for ownership.    \\\cline{1-5}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Shared Ownership ({\ttfamily std\+::shared\+\_\+ptr})\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   &Smart pointer that can have multiple owners. Uses reference counting to automatically delete the managed object when the last {\ttfamily shared\+\_\+ptr} to it is destroyed.   &{\ttfamily std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} p = std\+::make\+\_\+shared\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}(5);}   &When multiple parts of code need to share ownership.   &Prefer {\ttfamily std\+::make\+\_\+shared} for efficiency. Be cautious of cyclic references.    \\\cline{1-5}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Weak Ownership ({\ttfamily std\+::weak\+\_\+ptr})\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   &Companion to {\ttfamily shared\+\_\+ptr} that doesn\textquotesingle{}t participate in ownership. Used to break cyclic references.   &{\ttfamily std\+::weak\+\_\+ptr\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} w = p;} (where {\ttfamily p} is a {\ttfamily shared\+\_\+ptr})   &To observe or cache objects owned by {\ttfamily shared\+\_\+ptr} without extending their lifetimes.   &Use with {\ttfamily shared\+\_\+ptr} to avoid cycles. Always check if it\textquotesingle{}s expired before use.    \\\cline{1-5}
{\bfseries{Reference}}   &Alias for another variable. Doesn\textquotesingle{}t own the referred variable.   &{\ttfamily int\& ref = i;}   &When you want an alias to an existing object without copying.   &Don\textquotesingle{}t use references for ownership. Ensure the referred object outlives the reference.    \\\cline{1-5}
{\bfseries{Reference Counting}}   &Mechanism (often in conjunction with smart pointers) that tracks the number of references to a resource, deleting it when the count drops to zero.   &(Implicit in {\ttfamily std\+::shared\+\_\+ptr})   &Managing resources shared by multiple owners.   &Mostly abstracted by {\ttfamily shared\+\_\+ptr}. Be cautious of cyclic references.    \\\cline{1-5}
{\bfseries{Move Semantics}}   &Transfer of ownership from one entity to another, leaving the original in a valid but unspecified state.   &{\ttfamily std\+::vector\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} v2 = std\+::move(v1);}   &Efficiently transferring resources, especially in function returns or assignments.   &Use {\ttfamily std\+::move} cautiously. After moving from an object, avoid using it except to assign or destruct it.   \\\cline{1-5}
\end{longtabu}


{\bfseries{General Notes}}\+:


\begin{DoxyItemize}
\item Always prefer smart pointers ({\ttfamily std\+::unique\+\_\+ptr}, {\ttfamily std\+::shared\+\_\+ptr}) over raw pointers for ownership.
\item The stack is efficient and automatically managed, so prefer stack allocation when feasible.
\item Move semantics, introduced in C++11, provide efficient ways to transfer ownership without unnecessary deep copies.
\item Raw pointers should be reserved for non-\/owning scenarios or interfaces with C libraries. 
\end{DoxyItemize}