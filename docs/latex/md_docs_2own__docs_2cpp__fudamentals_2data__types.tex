\chapter{Data Types in CPP}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2data__types}{}\label{md_docs_2own__docs_2cpp__fudamentals_2data__types}\index{Data Types in CPP@{Data Types in CPP}}
\label{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md85}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md85}%

\begin{DoxyItemize}
\item Let\textquotesingle{}s cover the fundamental built-\/in data types in C++. The sizes of these data types can vary depending on the architecture and compiler used, but I\textquotesingle{}ll give you a typical size on a modern system (such as a 64-\/bit machine using a GCC or Clang compiler). You mentioned types like {\ttfamily upsize\+\_\+t}, but I believe you meant types like {\ttfamily size\+\_\+t} or perhaps types with a suffix like {\ttfamily \+\_\+t}. These are typedefs in the C++ standard library.
\end{DoxyItemize}

Here\textquotesingle{}s a table for built-\/in data types\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Bytes (Hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Size (Bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Bytes (Hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Size (Bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}    }\\\cline{1-5}
\endhead
{\ttfamily bool}   &Boolean value.   &0x01   &1   &{\ttfamily bool flag = true;}    \\\cline{1-5}
{\ttfamily char}   &Character/byte.   &0x01   &1   &`char ch = \textquotesingle{}A';{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Odd"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}wchar\+\_\+t{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Wide character. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x02 or 0x04 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 2 or 4 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}wchar\+\_\+t wch = L\textquotesingle{}A\textquotesingle{};{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Even"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}short{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Short integer. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x02 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 2 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}short sh = 100;{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Odd"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}int{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Integer. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x04 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 4 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}int num = 1000;{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Even"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Long integer. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x04 or 0x08 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 4 or 8 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long ln = 10000L;{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Odd"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long long{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Very long integer. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x08 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 8 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long long ll = 100000LL;{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Even"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}float{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Floating point number. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x04 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 4 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}float fl = \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{10.\+5f};{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Odd"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}double{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Double floating point. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x08 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 8 \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}double db = \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{10.\+5};{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr class="{}markdown\+Table\+Row\+Even"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long double{\ttfamily \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} Extended precision float. \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 0x10 or varies \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>} 16 or varies \textbackslash{}ilinebr \texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td class="{}markdown\+Table\+Body\+None"{}\texorpdfstring{$>$}{>}}long double ldb = \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{10.\+5L};\`{}   \\\cline{1-5}
\end{longtabu}


For typedefs that are commonly used\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Typical Bytes (Hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Typical Size (Bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Typical Bytes (Hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Typical Size (Bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}    }\\\cline{1-5}
\endhead
{\ttfamily size\+\_\+t}   &Unsigned type of the result of {\ttfamily sizeof}.   &0x08   &8   &{\ttfamily size\+\_\+t sz = sizeof(int);}    \\\cline{1-5}
{\ttfamily ptrdiff\+\_\+t}   &Signed type to hold pointer subtraction.   &0x08   &8   &{\ttfamily ptrdiff\+\_\+t diff = p2 -\/ p1;} (where p1, p2 are pointers)    \\\cline{1-5}
{\ttfamily int8\+\_\+t}   &Fixed-\/width 8-\/bit integer.   &0x01   &1   &{\ttfamily int8\+\_\+t val = 10;}    \\\cline{1-5}
{\ttfamily uint8\+\_\+t}   &Fixed-\/width unsigned 8-\/bit integer.   &0x01   &1   &{\ttfamily uint8\+\_\+t uval = 10;}   \\\cline{1-5}
\end{longtabu}


... and so on for {\ttfamily int16\+\_\+t}, {\ttfamily int32\+\_\+t}, {\ttfamily int64\+\_\+t} and their unsigned counterparts.

Please note\+:


\begin{DoxyItemize}
\item The sizes are given for typical modern systems. Always use the {\ttfamily sizeof} operator to verify sizes in your specific system.
\item {\ttfamily \+\_\+t} suffix types are part of the C++ standard library (specifically from the {\ttfamily \texorpdfstring{$<$}{<}cstdint\texorpdfstring{$>$}{>}} header) and represent fixed-\/width integer types.
\end{DoxyItemize}

Also, remember to include the appropriate headers when working with specific data types, especially the typedefs.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md86}{}\doxysection{\texorpdfstring{Representation in Memory}{Representation in Memory}}\label{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md86}
Given the complexity and extensiveness of this request, this table will give a comprehensive view of basic primitive data types. Some sizes are platform-\/dependent (specifically, architecture like 32-\/bit vs. 64-\/bit systems can affect them), but the table provides general sizes for a typical 64-\/bit system. For non-\/primitive types like string, array, map, their size is more complicated and depends on their content and implementation.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Size (bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example (hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example (binary)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Range}}    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Size (bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example (hex)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example (binary)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Range}}    }\\\cline{1-6}
\endhead
{\ttfamily char}   &1   &{\ttfamily 0x41}   &{\ttfamily 01000001}   &8 bits   &-\/128 to 127 (or 0 to 255 for {\ttfamily unsigned char})    \\\cline{1-6}
{\ttfamily short}   &2   &{\ttfamily 0x0123}   &{\ttfamily 0000000100100011}   &16 bits   &-\/32,768 to 32,767    \\\cline{1-6}
{\ttfamily int}   &4   &{\ttfamily 0x01234567}   &32 bits   &32 bits   &-\/2,147,483,648 to 2,147,483,647    \\\cline{1-6}
{\ttfamily long}   &8 (typically)   &{\ttfamily 0x0123456789\+ABCDEF}   &64 bits   &64 bits   &-\/9,223,372,036,854,775,808 to 9,223,372,036,854,775,807    \\\cline{1-6}
{\ttfamily float}   &4   &Depends on value   &Depends on value   &IEEE 754   &\texorpdfstring{$\sim$}{\string~}1.4E-\/45 to \texorpdfstring{$\sim$}{\string~}3.4E38    \\\cline{1-6}
{\ttfamily double}   &8   &Depends on value   &Depends on value   &IEEE 754   &\texorpdfstring{$\sim$}{\string~}5.0E-\/324 to \texorpdfstring{$\sim$}{\string~}1.7E308    \\\cline{1-6}
{\ttfamily bool}   &1 (typically)   &N/A   &{\ttfamily 00000001} (true)   &8 bits   &{\ttfamily true} or {\ttfamily false}    \\\cline{1-6}
{\ttfamily wchar\+\_\+t}   &2 or 4   &Depends on value   &Depends on value   &Platform-\/dependent   &Platform-\/dependent    \\\cline{1-6}
{\ttfamily long long}   &8   &{\ttfamily 0x0123456789\+ABCDEF}   &64 bits   &64 bits   &-\/9,223,372,036,854,775,808 to 9,223,372,036,854,775,807   \\\cline{1-6}
\end{longtabu}


For non-\/primitive types\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Base Size (bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Notes}}    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Type}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Base Size (bytes)}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Notes}}    }\\\cline{1-3}
\endhead
{\ttfamily std\+::string}   &Depends on implementation and content   &Size is dynamic, depends on the number of characters stored + overhead.    \\\cline{1-3}
{\ttfamily std\+::array}   &Depends on type and size   &Size is {\ttfamily sizeof(type) \texorpdfstring{$\ast$}{*} number\+\_\+of\+\_\+elements}.    \\\cline{1-3}
{\ttfamily std\+::vector}   &Dynamic   &Size changes as elements are added/removed. Memory is allocated on the heap.    \\\cline{1-3}
{\ttfamily std\+::map}   &Dynamic   &Size depends on the number of key-\/value pairs and the types used. Memory usually on the heap.   \\\cline{1-3}
\end{longtabu}


{\bfseries{Notes}}\+:


\begin{DoxyEnumerate}
\item The exact size of some data types can vary between platforms and compilers.
\item For non-\/primitive types, the actual memory used can be more due to dynamic allocations, especially for data structures that manage their memory like {\ttfamily std\+::string} or {\ttfamily std\+::vector}.
\item Modern C++ provides fixed-\/width integer types in the header {\ttfamily \texorpdfstring{$<$}{<}cstdint\texorpdfstring{$>$}{>}}, like {\ttfamily int16\+\_\+t}, {\ttfamily int32\+\_\+t}, {\ttfamily int64\+\_\+t}, etc., which have sizes guaranteed to be 2, 4, and 8 bytes, respectively.
\end{DoxyEnumerate}

To get the exact size of any type in a specific environment, one can use the {\ttfamily sizeof} operator in C++. For instance, {\ttfamily sizeof(int)} will give the size of an int in bytes for the specific platform/compiler being used.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md87}{}\doxysection{\texorpdfstring{Block Memory given same number}{Block Memory given same number}}\label{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md87}
Alright, we\textquotesingle{}ll create a table that provides a memory block view of integer and floating-\/point numbers for the examples you provided. We will focus on a 32-\/bit representation for both integers (using {\ttfamily int}) and floating-\/point numbers (using {\ttfamily float}) for simplicity. Note that the representation might vary depending on the system and compiler.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-4}
\endhead
int (14)   &{\ttfamily 0x0000000E}   &{\ttfamily 00000000 00000000 00000000 00001110}   &00 00 00 0E    \\\cline{1-4}
int (-\/14)   &{\ttfamily 0x\+FFFFFFF2}   &{\ttfamily 11111111 11111111 11111111 11110010}   &FF FF FF F2    \\\cline{1-4}
float (\doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{14.\+0})   &{\ttfamily 0x41700000}   &{\ttfamily 01000001 01110000 00000000 00000000}   &41 70 00 00    \\\cline{1-4}
float (\doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{-\/14.\+0})   &{\ttfamily 0x\+C1700000}   &{\ttfamily 11000001 01110000 00000000 00000000}   &C1 70 00 00   \\\cline{1-4}
\end{longtabu}


{\bfseries{Memory Profile Explanation}}\+:


\begin{DoxyItemize}
\item For {\ttfamily int}, it\textquotesingle{}s a straightforward 2\textquotesingle{}s complement representation.
\item For {\ttfamily float}, it uses IEEE 754 single-\/precision floating-\/point format, where the first bit is the sign bit (1 for negative, 0 for positive), followed by an 8-\/bit exponent, and then a 23-\/bit fraction (or mantissa).
\end{DoxyItemize}

{\bfseries{Note}}\+: The floating-\/point representation might not be intuitive just by looking at the binary. It\textquotesingle{}s a mix of sign, exponent, and fractional bits. The exact binary and hex representation for floating-\/point numbers might vary based on the specifics of the IEEE 754 implementation in a particular environment.


\begin{DoxyItemize}
\item The "{}\+Memory Profile (byte-\/by-\/byte)"{} column presents a big-\/endian view. Actual representation in memory could be little-\/endian on some systems, which means the bytes would be in reverse order.
\item Representing the string "{}abc"{} in various formats, keeping in mind a 32-\/bit system (and assuming an 8-\/bit {\ttfamily char})\+:
\end{DoxyItemize}
\begin{DoxyEnumerate}
\item {\bfseries{String Literal (C-\/\+Style)}}\+: Strings are null-\/terminated sequences of characters. For the string "{}abc"{}, it is represented as \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{}, and \textquotesingle{}\textbackslash{}0\textquotesingle{}.
\item {\bfseries{std\+::string}}\+: This is a more complex data type from the C++ Standard Library, and its internal representation can differ based on the implementation. A {\ttfamily std\+::string} typically contains a pointer to dynamic memory where the actual string is stored, a size, and a capacity. The dynamic memory would hold our \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{}, and \textquotesingle{}\textbackslash{}0\textquotesingle{}.
\end{DoxyEnumerate}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-4}
\endhead
String Literal "{}abc"{}   &{\ttfamily 0x61626300}   &{\ttfamily 01100001 01100010 01100011 00000000}   &61 62 63 00    \\\cline{1-4}
std\+::string "{}abc"{} (simplified)   &Varies based on implementation   &Varies based on implementation   &Varies based on internal {\ttfamily std\+::string} layout   \\\cline{1-4}
\end{longtabu}


{\bfseries{Memory Profile Explanation}}\+:


\begin{DoxyItemize}
\item For the String Literal, "{}abc"{} is represented in ASCII values. The characters \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, and \textquotesingle{}c\textquotesingle{} correspond to ASCII values 97, 98, and 99 respectively. The null terminator \textquotesingle{}\textbackslash{}0\textquotesingle{} corresponds to ASCII value 0.
\item For {\ttfamily std\+::string}, it\textquotesingle{}s a bit more complicated. The internal representation will depend on the library\textquotesingle{}s implementation and might include dynamic memory allocation. The hex and binary values will differ based on that representation.
\end{DoxyItemize}

Note\+: The memory profile provided is a simplistic representation. Actual memory layout can differ based on system, compiler, and standard library version. For a precise representation, one would have to delve into the specific {\ttfamily std\+::string} implementation or use tools like memory profilers or debuggers.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md88}{}\doxysection{\texorpdfstring{Memory Profile for Array}{Memory Profile for Array}}\label{md_docs_2own__docs_2cpp__fudamentals_2data__types_autotoc_md88}
Let\textquotesingle{}s start by setting a context\+: Let\textquotesingle{}s consider an array, a vector, and a map, each storing pairs of integers, such as {\ttfamily (1,2)}, {\ttfamily (3,4)}, and {\ttfamily (5,6)}.


\begin{DoxyEnumerate}
\item {\bfseries{Array}}\+: In C++, an array is a fixed-\/size container. If we consider an array of pairs, we can represent it as {\ttfamily std\+::pair\texorpdfstring{$<$}{<}int, int\texorpdfstring{$>$}{>}\mbox{[}3\mbox{]}}.
\item {\bfseries{std\+::vector}}\+: This is a dynamic array in C++. It has the flexibility to grow or shrink. The memory profile of a vector consists of pointers to dynamic memory, a size, and a capacity.
\item {\bfseries{std\+::map}}\+: An associative container that stores elements in key-\/value pairs. Internally, many implementations of {\ttfamily std\+::map} use a balanced binary tree (like a red-\/black tree). This means each node contains a pair (key, value), and pointers to left and right child nodes.
\end{DoxyEnumerate}

Here\textquotesingle{}s the table with a simple representation\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex \& Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Type/\+Value}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Hex \& Binary Representation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Memory Profile (byte-\/by-\/byte)}}    }\\\cline{1-3}
\endhead
Array ({\ttfamily std\+::pair\texorpdfstring{$<$}{<}int, int\texorpdfstring{$>$}{>}\mbox{[}3\mbox{]}})   &Depends on layout in memory   &Sequence of 6 integers; no metadata (so, directly the hex values of 1, 2, 3, 4, 5, 6)    \\\cline{1-3}
std\+::vector ({\ttfamily std\+::vector\texorpdfstring{$<$}{<}std\+::pair\texorpdfstring{$<$}{<}int, int\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}})   &Varies with implementation   &Pointer(s) to dynamic memory, size, capacity; dynamic memory will have the hex values of the pairs    \\\cline{1-3}
std\+::map ({\ttfamily std\+::map\texorpdfstring{$<$}{<}int, int\texorpdfstring{$>$}{>}})   &Varies with implementation   &Nodes with key-\/value pair and pointers to left/right child; exact memory profile varies   \\\cline{1-3}
\end{longtabu}


{\bfseries{Memory Profile Explanation}}\+:


\begin{DoxyItemize}
\item {\bfseries{Array}}\+: Straightforward sequence of data without any overhead or metadata.
\item {\bfseries{std\+::vector}}\+: Contains overhead for size, capacity, and \doxylink{_s_d_l__opengl__glext_8h_a114e561b64eeccad5bc17f0f799e1e08}{pointer(s)} to dynamic memory. The dynamic memory contains the actual values.
\item {\bfseries{std\+::map}}\+: Due to its tree-\/based structure, there\textquotesingle{}s significant overhead for maintaining the tree (pointers to left and right children, maybe color information for balancing, etc.), on top of the key-\/value data.
\end{DoxyItemize}

Note\+: The exact memory profile will depend on the system, compiler, and standard library version. The representations above are simplifications to convey the conceptual differences. Actual layouts, especially for complex structures like {\ttfamily std\+::map}, may involve additional metadata and differ substantially from this basic outline. For precise representation, specialized tools or diving into specific library implementations would be necessary. 