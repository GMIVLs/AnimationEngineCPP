\chapter{HOW CPP WORKS -\/ Deep Dive}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works}{}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works}\index{HOW CPP WORKS -\/ Deep Dive@{HOW CPP WORKS -\/ Deep Dive}}
\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md64}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md64}%
 {\bfseries{Table of Contents}}


\begin{DoxyItemize}
\item HOW CPP WORKS -\/ Deep Dive
\begin{DoxyItemize}
\item Main C++ Working
\begin{DoxyItemize}
\item The key terms are\+:
\end{DoxyItemize}
\item ASCII diagram to illustrate the process\+:
\begin{DoxyItemize}
\item Explanation of steps\+:
\end{DoxyItemize}
\item Where the translation unit and where is the object file
\item Static Linking with Third Party Library
\item Dynamic Linking
\item Files Types in Building Process
\item Can a Project has several translation units?
\item Header files
\item Guards for Directives (\#include)
\item Q\&A Sessionn
\begin{DoxyItemize}
\item Question -\/1
\item Question -\/2
\item Question -\/3
\item Question -\/4
\item Question -\/5
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md65}{}\doxysection{\texorpdfstring{Main C++ Working}{Main C++ Working}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md65}
When you\textquotesingle{}re working with C++ and you have a set of source files like {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}, {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}}, and a header file {\ttfamily lib.\+h}, you\textquotesingle{}re dealing with multiple steps of compilation and linking.

Here\textquotesingle{}s what happens step-\/by-\/step\+:


\begin{DoxyEnumerate}
\item {\bfseries{Preprocessing}}\+: Before actual compilation, the preprocessor handles directives such as {\ttfamily \#include}, {\ttfamily \#define}, and {\ttfamily \#ifdef}. For your {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}}, the {\ttfamily \#include "{}lib.\+h"{}} directive would cause the content of {\ttfamily lib.\+h} to be included (copied) into each of those cpp files. This step doesn\textquotesingle{}t produce any files you interact with; it\textquotesingle{}s done in-\/memory before compilation.
\item {\bfseries{Compilation}}\+: Each cpp file is compiled separately. The compiler translates {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} into {\ttfamily main.\+o} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} into {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}. These are called object files. This is the step where the compiler checks for syntax errors and other language rules. After this step, each object file contains machine code, but it\textquotesingle{}s not yet executable because it might contain unresolved symbols that it expects to find in other object files.
\begin{DoxyItemize}
\item {\ttfamily main.\+o} is a translation unit corresponding to {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} after preprocessing.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}} is a translation unit corresponding to {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} after preprocessing.
\end{DoxyItemize}
\item {\bfseries{Linking}}\+: The linker takes all object files ({\ttfamily main.\+o}, {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}) and resolves any references between them. If {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} calls a function that\textquotesingle{}s implemented in {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}}, the linker connects these two parts together. The result is an executable file (like {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{a.\+out}} on Unix systems or {\ttfamily main.\+exe} on Windows).
\item {\bfseries{Execution}}\+: You can now run the executable file on your computer. If there were no linking errors, and your code is correctly written, it should execute and produce whatever output your program is designed to produce.
\end{DoxyEnumerate}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md66}{}\doxysubsection{\texorpdfstring{The key terms are\+:}{The key terms are:}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md66}

\begin{DoxyItemize}
\item {\bfseries{Source files}}\+: The original {\ttfamily .cpp} and {\ttfamily .h} files you write.
\item {\bfseries{Translation units}}\+: The combination of a source file and all the headers it includes, after preprocessing.
\item {\bfseries{Object files}}\+: The machine code output from compiling a translation unit, typically with {\ttfamily .o} or {\ttfamily .obj} extension.
\item {\bfseries{Executable}}\+: The final runnable program created by the linker.
\end{DoxyItemize}

The resulting executable is what you run on your computer. The intermediary files, like the object files, are usually not needed once the final linking is done, unless you\textquotesingle{}re doing incremental compilation.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md67}{}\doxysection{\texorpdfstring{ASCII diagram to illustrate the process\+:}{ASCII diagram to illustrate the process:}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md67}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ Step\ 1:\ Preprocessing}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.cpp\ \ \ \ \ \ lib.cpp\ \ \ \ \ lib.h}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \#include\ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{<iostream>\ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \#include\ "{}lib.h"{}\ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \#include\ "{}lib.h"{}}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i}
\DoxyCodeLine{}
\DoxyCodeLine{Step\ 2:\ Compilation}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ Compiles\ \ \ \ |\ Compiles}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{}
\DoxyCodeLine{Step\ 3:\ Linking}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ Linker\ \ \ \ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ \ \ \ v}
\DoxyCodeLine{\ \ \ \ \ program}
\DoxyCodeLine{\ \ \ \ \ (a.out)}

\end{DoxyCode}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md68}{}\doxysubsection{\texorpdfstring{Explanation of steps\+:}{Explanation of steps:}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md68}

\begin{DoxyEnumerate}
\item {\bfseries{Preprocessing}}\+:
\begin{DoxyItemize}
\item {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} includes {\ttfamily iostream} and {\ttfamily lib.\+h}. The content of {\ttfamily iostream} and {\ttfamily lib.\+h} is effectively copied into {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} to create {\ttfamily main.\+i}.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} includes {\ttfamily lib.\+h}. The content of {\ttfamily lib.\+h} is copied into {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} to create {\ttfamily lib.\+i}.
\item The {\ttfamily .i} files are preprocessed source files, which you usually don\textquotesingle{}t see as they are intermediate and kept in memory.
\end{DoxyItemize}
\item {\bfseries{Compilation}}\+:
\begin{DoxyItemize}
\item {\ttfamily main.\+i} is compiled into an object file {\ttfamily main.\+o}.
\item {\ttfamily lib.\+i} is compiled into an object file {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}.
\item The {\ttfamily .o} files contain the compiled machine code, but external references are not resolved yet.
\end{DoxyItemize}
\item {\bfseries{Linking}}\+:
\begin{DoxyItemize}
\item The linker takes all the object files ({\ttfamily main.\+o}, {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}) and resolves symbols, references, etc., to produce the final executable ({\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{a.\+out}} on Unix-\/like systems).
\end{DoxyItemize}
\end{DoxyEnumerate}

Each {\ttfamily .cpp} file is processed independently until the linking stage, where the generated object files are combined to create the final executable.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md69}{}\doxysection{\texorpdfstring{Where the translation unit and where is the object file}{Where the translation unit and where is the object file}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md69}
the ASCII diagram updated to include where the translation units and object files come into play\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ Step\ 1:\ Preprocessing}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.cpp\ \ \ \ \ \ lib.cpp\ \ \ \ \ lib.h}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \#include\ \ \ \ |\ \#include\ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i\ \ \ \ \ \ \ |}
\DoxyCodeLine{(Translation\ (Translation\ |}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)\ \ \ \ \ \ \ |}
\DoxyCodeLine{}
\DoxyCodeLine{\ Step\ 2:\ Compilation}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i}
\DoxyCodeLine{(Translation\ (Translation}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ Compiles\ \ \ \ |\ Compiles}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)}
\DoxyCodeLine{}
\DoxyCodeLine{\ Step\ 3:\ Linking}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ Linker\ \ \ \ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ \ \ \ v}
\DoxyCodeLine{\ \ \ \ \ program}
\DoxyCodeLine{\ \ \ (Executable)}

\end{DoxyCode}


{\bfseries{Explanation of additions\+:}}


\begin{DoxyItemize}
\item {\bfseries{Translation Units}}\+: After preprocessing, {\ttfamily main.\+i} and {\ttfamily lib.\+i} are the translation units. These consist of the source code in {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}}, with the contents of {\ttfamily lib.\+h} and any other included headers (like {\ttfamily iostream} for {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}) directly inserted in place of the {\ttfamily \#include} directives.
\item {\bfseries{Object Files}}\+: The result of compiling each translation unit is an object file. {\ttfamily main.\+o} is the object file for {\ttfamily main.\+i}, and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}} is the object file for {\ttfamily lib.\+i}. These contain the compiled code in a binary format, but not yet linked to other object files.
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md70}{}\doxysection{\texorpdfstring{Static Linking with Third Party Library}{Static Linking with Third Party Library}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md70}
I\textquotesingle{}ll illustrate how static linking with a third-\/party library works across different platforms. Let\textquotesingle{}s assume we have a static library named {\ttfamily libthirdparty}.

On Windows, static libraries typically have a {\ttfamily .lib} extension, on mac\+OS and Linux, the extension is usually {\ttfamily .a}.

Here\textquotesingle{}s the updated ASCII diagram\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ Step\ 1:\ Preprocessing}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.cpp\ \ \ \ \ \ lib.cpp\ \ \ \ \ lib.h\ \ \ \ \ libthirdparty\ (Third-\/Party\ Library)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \#include\ \ \ \ |\ \#include\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i\ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ libthirdparty.lib\ (Windows)}
\DoxyCodeLine{(Translation\ (Translation\ |\ \ \ \ \ \ \ \ \ \ \ libthirdparty.a\ \ \ (macOS/Linux)}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)\ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ (Static\ Library)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ Step\ 2:\ Compilation}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i}
\DoxyCodeLine{(Translation\ (Translation}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ Compiles\ \ \ \ |\ Compiles}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)}
\DoxyCodeLine{}
\DoxyCodeLine{\ Step\ 3:\ Linking\ (with\ Static\ Library)}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o\ \ \ \ \ \ \ libthirdparty.lib\ (Windows)}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object\ \ \ \ \ libthirdparty.a\ \ \ (macOS/Linux)}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)\ \ \ \ \ \ \ (Static\ Library)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ Linker\ \ \ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ \ \ \ v}
\DoxyCodeLine{\ \ \ \ \ program.exe\ (Windows)}
\DoxyCodeLine{\ \ \ \ \ program\ \ \ \ \ (macOS/Linux)}
\DoxyCodeLine{\ \ \ (Executable)}

\end{DoxyCode}


{\bfseries{Explanation of additions\+:}}


\begin{DoxyItemize}
\item {\bfseries{Static Library}}\+: The third-\/party static library {\ttfamily libthirdparty} is shown here before linking. It is included by the linker, not by the preprocessor, so it doesn\textquotesingle{}t go through the preprocessing or compilation stages that your own source code does.
\item {\bfseries{Linking with Static Library}}\+: During the linking step, the static library ({\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{libthirdparty.\+lib}} for Windows, {\ttfamily libthirdparty.\+a} for mac\+OS and Linux) is combined with your object files ({\ttfamily main.\+o} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}) to produce the final executable. Static linking copies the library code into your executable at build time, so the library becomes part of your application.
\end{DoxyItemize}

When you compile and link your program, you\textquotesingle{}ll need to tell the compiler/linker where to find the {\ttfamily libthirdparty} library files and how to include them. This is typically done through command-\/line arguments or project settings in your development environment.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md71}{}\doxysection{\texorpdfstring{Dynamic Linking}{Dynamic Linking}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md71}
Dynamic linking involves linking against shared libraries (also known as Dynamic Link Libraries (DLL) on Windows or Shared Objects (.so) on Unix-\/like systems such as Linux and mac\+OS). Unlike static libraries, dynamic libraries are not embedded into the executable at link time; instead, they are loaded at runtime.

Here’s how the ASCII diagram would look with dynamic linking\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ Step\ 1:\ Preprocessing}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.cpp\ \ \ \ \ \ lib.cpp\ \ \ \ \ lib.h\ \ \ \ \ libthirdparty\ (Third-\/Party\ Library)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \#include\ \ \ \ |\ \#include\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i\ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ libthirdparty.dll\ (Windows)}
\DoxyCodeLine{(Translation\ (Translation\ |\ \ \ \ \ \ \ \ \ \ \ libthirdparty.so\ \ (macOS/Linux)}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)\ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ (Dynamic\ Library)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ Step\ 2:\ Compilation}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.i\ \ \ \ \ \ \ \ lib.i}
\DoxyCodeLine{(Translation\ (Translation}
\DoxyCodeLine{\ Unit)\ \ \ \ \ \ \ \ Unit)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ Compiles\ \ \ \ |\ Compiles}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)}
\DoxyCodeLine{}
\DoxyCodeLine{\ Step\ 3:\ Linking\ (with\ Dynamic\ Library)}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{main.o\ \ \ \ \ \ \ \ lib.o\ \ \ \ \ \ \ libthirdparty.dll\ (Windows)}
\DoxyCodeLine{(Object\ \ \ \ \ \ \ (Object\ \ \ \ \ libthirdparty.so\ \ (macOS/Linux)}
\DoxyCodeLine{\ File)\ \ \ \ \ \ \ \ File)\ \ \ \ \ \ \ (Dynamic\ Library)}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ |\ \ \ Linker\ \ \ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|}
\DoxyCodeLine{\ \ |-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/|\ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v}
\DoxyCodeLine{\ \ \ \ \ program.exe\ \ \ \ \ \ \ \ \ \ \ Loaded\ at}
\DoxyCodeLine{\ \ \ \ \ program\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Runtime}
\DoxyCodeLine{\ \ \ (Executable)}

\end{DoxyCode}


{\bfseries{Explanation of changes for Dynamic Linking\+:}}


\begin{DoxyItemize}
\item {\bfseries{Dynamic Library}}\+: {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{libthirdparty.\+dll}} for Windows or {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{libthirdparty.\+so}} for Unix-\/like systems represents the dynamic library. The dynamic library itself isn\textquotesingle{}t included in the linking step to be part of the executable. Instead, information about where to find the dynamic library at runtime is included.
\item {\bfseries{Linking with Dynamic Library}}\+: During the linking phase, the executable is prepared to call into the dynamic library. It knows the names of the functions it needs to call, but not where they are located in memory.
\item {\bfseries{Runtime}}\+: When the program runs, the operating system loads the dynamic library into memory, and the program uses the OS-\/provided mechanisms to call functions within the dynamically linked library.
\end{DoxyItemize}

{\bfseries{Note\texorpdfstring{$\ast$}{*}}}\+: that when distributing your application, you need to ensure that the target system has access to the required dynamic library at the correct version, or the application won\textquotesingle{}t run. This is often managed by installing the library in a standard location, using the operating system\textquotesingle{}s package management, or by distributing the library alongside the application with appropriate paths set.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md72}{}\doxysection{\texorpdfstring{Files Types in Building Process}{Files Types in Building Process}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md72}
Can you make a table for all files types that is generated in this process? Here is a table summarizing the different file types generated during the C++ compilation process and their meanings\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Extension   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platform   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Extension   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platform   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily .cpp}   &Cross-\/\+Platform   &C++ Source file which contains the code written by the programmer.    \\\cline{1-3}
{\ttfamily .h}   &Cross-\/\+Platform   &Header file which typically contains function declarations and macros.    \\\cline{1-3}
{\ttfamily .hpp}   &Cross-\/\+Platform   &C++ Header file, similar to {\ttfamily .h} but specifically for C++ declarations.    \\\cline{1-3}
{\ttfamily .i}   &Cross-\/\+Platform   &Preprocessed source file (rarely seen; often a temporary file).    \\\cline{1-3}
{\ttfamily .o}   &Unix-\/like   &Object file, contains machine code generated by the compiler.    \\\cline{1-3}
{\ttfamily .obj}   &Windows   &Object file, contains machine code generated by the compiler.    \\\cline{1-3}
{\ttfamily .a}   &Unix-\/like   &Static library, an archive of object files for static linking.    \\\cline{1-3}
{\ttfamily .lib}   &Windows   &Static library file or an import library for dynamic linking.    \\\cline{1-3}
{\ttfamily .so}   &Unix-\/like   &Shared Object, dynamic library loaded at runtime.    \\\cline{1-3}
{\ttfamily .dll}   &Windows   &Dynamic Link Library, dynamic library loaded at runtime.    \\\cline{1-3}
{\ttfamily .exe}   &Windows   &Executable file, the final runnable program.    \\\cline{1-3}
(No extension)   &Unix-\/like   &Executable file, the final runnable program.    \\\cline{1-3}
{\ttfamily .dylib}   &mac\+OS   &Dynamic library, similar to {\ttfamily .so}, used in mac\+OS.    \\\cline{1-3}
{\ttfamily .d\+SYM}   &mac\+OS   &Debug symbols file, contains debug information for use in a debugger.    \\\cline{1-3}
\`{}.pdb\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   &Windows   &Program Database, stores debugging information about a program.   \\\cline{1-3}
\end{longtabu}


{\bfseries{Note\texorpdfstring{$\ast$}{*}}}\+: This table does not cover every possible file type associated with C++ development, such as those used by various Integrated Development Environments (IDEs) for project management or by other tools for resources, but it does cover the main file types produced and used during the build process.


\begin{DoxyItemize}
\item Here is an expanded version of the table with {\ttfamily .dylib} included and other relevant file types\+:
\end{DoxyItemize}

This table includes file extensions for debug symbols which are also an important part of the development process, especially when debugging applications. Debug symbols are generated alongside executables and libraries to provide a mapping from the binary code to the original source code, making it possible to step through the source code during debugging sessions.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md73}{}\doxysection{\texorpdfstring{Can a Project has several translation units?}{Can a Project has several translation units?}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md73}
Yes, a project can have several translation units. In fact, it\textquotesingle{}s quite common in larger C++ projects. A translation unit is essentially a single compiled source file, but it includes all the headers and included source files that are brought in via {\ttfamily \#include} preprocessor directives. Here\textquotesingle{}s how it works\+:


\begin{DoxyEnumerate}
\item {\bfseries{Each {\ttfamily .cpp} File Is a Separate Translation Unit}}\+: When you compile a {\ttfamily .cpp} file, the compiler processes it along with all the included headers and generates one object file ({\ttfamily .o} or {\ttfamily .obj}) per {\ttfamily .cpp} file. Each of these is a translation unit.
\item {\bfseries{Headers Are Not Translation Units}}\+: Header files ({\ttfamily .h} or {\ttfamily .hpp}) are not compiled on their own; they are included in one or more {\ttfamily .cpp} files. They become part of a translation unit when they are included and processed in a {\ttfamily .cpp} file.
\item {\bfseries{Linking Translation Units}}\+: After all the individual translation units have been compiled into object files, a linker combines all the object files into a single executable (or library). If there are multiple {\ttfamily .cpp} files, the linker resolves cross-\/references between them.
\end{DoxyEnumerate}

Here\textquotesingle{}s an example with multiple {\ttfamily .cpp} files in a project\+:


\begin{DoxyItemize}
\item {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} includes {\ttfamily main.\+h} and possibly other headers.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{utils.\+cpp}} includes {\ttfamily utils.\+h}.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{network.\+cpp}} includes {\ttfamily network.\+h}.
\end{DoxyItemize}

Each of these {\ttfamily .cpp} files will be compiled into its own object file\+:


\begin{DoxyItemize}
\item {\ttfamily main.\+o}
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{utils.\+o}}
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{network.\+o}}
\end{DoxyItemize}

These object files are then linked together to create the final executable program. Each {\ttfamily .cpp} file and the headers it includes form separate translation units during the compilation process.

Here\textquotesingle{}s a table defining various terms related to the C++ build process\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Term   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Meaning   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Associated File Extension(s)    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Term   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Meaning   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Associated File Extension(s)    }\\\cline{1-3}
\endhead
Source File   &Contains code written by the programmer. It\textquotesingle{}s the starting point of the compilation process.   &{\ttfamily .cpp}, {\ttfamily .cc}, {\ttfamily .cxx}, {\ttfamily .c++}    \\\cline{1-3}
Header File   &Used to declare the structure of the program. Contains declarations of functions, classes, etc.   &{\ttfamily .h}, {\ttfamily .hpp}    \\\cline{1-3}
Translation Unit   &The result of processing a source file and all its included headers and source files.   &N/A (conceptual, corresponds to a {\ttfamily .cpp} file pre-\/compilation)    \\\cline{1-3}
Object File   &Contains machine code output by the compiler. It\textquotesingle{}s what the linker uses to create the executable.   &{\ttfamily .o} (Unix-\/like), {\ttfamily .obj} (Windows)    \\\cline{1-3}
Static Library   &An archive of object files, linked into an executable at build time.   &{\ttfamily .a} (Unix-\/like), {\ttfamily .lib} (Windows)    \\\cline{1-3}
Dynamic Library   &A library loaded at runtime, allowing for shared code across programs.   &{\ttfamily .so} (Unix-\/like), {\ttfamily .dll} (Windows), {\ttfamily .dylib} (mac\+OS)    \\\cline{1-3}
Executable   &The final runnable program file resulting from the linking process.   &{\ttfamily .exe} (Windows), (No extension or {\ttfamily .out}) (Unix-\/like), {\ttfamily .app} (mac\+OS)    \\\cline{1-3}
Preprocessed File   &An intermediate file created after the preprocessing step. It\textquotesingle{}s not usually saved.   &{\ttfamily .i} (rarely used as a file extension)    \\\cline{1-3}
Standard Library   &A collection of classes and functions prescribed by the language standard.   &N/A (implemented in compilers, may be part of runtime)    \\\cline{1-3}
Import Library   &Used on some platforms like Windows to describe a dynamic library\textquotesingle{}s interface to the linker.   &{\ttfamily .lib} (Windows)    \\\cline{1-3}
Shared Object   &The Linux term for a dynamic library.   &{\ttfamily .so} (Unix-\/like)    \\\cline{1-3}
Dynamic Link Library   &The Windows term for a dynamic library.   &{\ttfamily .dll} (Windows)    \\\cline{1-3}
Archive File   &A static library in Unix-\/like systems.   &{\ttfamily .a} (Unix-\/like)    \\\cline{1-3}
Debug Symbols File   &Contains debug information, mapping the executable to the source code for debugging.   &{\ttfamily .pdb} (Windows), {\ttfamily .d\+SYM} (mac\+OS)   \\\cline{1-3}
\end{longtabu}


This table includes terms that represent both physical files (with extensions) and conceptual aspects of the build process (like the translation unit). The standard library files are usually part of the runtime and are typically pre-\/compiled with the compiler, not directly visible in the project file structure.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md74}{}\doxysection{\texorpdfstring{Header files}{Header files}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md74}
How the header will not repeated among the translation units in case it is mentioned twice


\begin{DoxyItemize}
\item To prevent a header from being included multiple times within the same translation unit, which can cause errors due to redefinition, C++ uses an "{}include guard."{} An include guard is a preprocessor technique that ensures a header file is only included once no matter how many times it\textquotesingle{}s requested by the preprocessor.
\end{DoxyItemize}

Here\textquotesingle{}s how include guards typically work\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifndef\ HEADER\_NAME\_H}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ HEADER\_NAME\_H}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ declarations\ and\ definitions}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HEADER\_NAME\_H}}

\end{DoxyCode}



\begin{DoxyItemize}
\item The {\ttfamily \#ifndef} directive checks if {\ttfamily HEADER\+\_\+\+NAME\+\_\+H} (a unique macro name) has been defined. If not, it defines {\ttfamily HEADER\+\_\+\+NAME\+\_\+H} and allows the inclusion of the header\textquotesingle{}s contents. The next time the preprocessor encounters this header, {\ttfamily HEADER\+\_\+\+NAME\+\_\+H} will already be defined, so the contents within the {\ttfamily \#ifndef} and {\ttfamily \#endif} block will be ignored.
\item Include guards are standard practice in C++ programming and are essential for preventing multiple inclusions of the same header in a single translation unit.
\item When multiple translation units include the same header, each translation unit is compiled separately, so the include guard only prevents multiple inclusions within each translation unit. The linker is responsible for handling the definitions when the separate translation units are combined into a single executable or library, ensuring there are no duplicate symbols.
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md75}{}\doxysection{\texorpdfstring{Guards for Directives (\#include)}{Guards for Directives (\#include)}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md75}
Yes, include guards are also relevant for standard library headers like {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}}. However, standard library implementations handle this internally so that when you include a standard library header like {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} in multiple source files (translation units), each one will only include it once during compilation. This is to prevent multiple definitions and other issues that might arise from including the same declarations multiple times in a single translation unit.

In your example, including {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} in both {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} works without issues\+:


\begin{DoxyItemize}
\item {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} includes {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}}. The preprocessor includes the content of {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} in the translation unit that is being compiled from {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} includes {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}}. The same process occurs separately, as {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} is another translation unit.
\end{DoxyItemize}

After preprocessing and compilation, both {\ttfamily main.\+o} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}} will have their own compiled code from {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}}. The linker then takes over and ensures that any standard library code is properly managed, and the final executable has only one set of definitions for the standard library functions used, regardless of how many times they were included in different translation units.

The C++ Standard Library and its headers are designed to be included in multiple translation units; it\textquotesingle{}s a fundamental part of supporting modular compilation.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md76}{}\doxysection{\texorpdfstring{Q\&\+A Sessionn}{Q\&A Sessionn}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md76}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md77}{}\doxysubsection{\texorpdfstring{Question -\/1}{Question -1}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md77}

\begin{DoxyItemize}
\item Explain more about the translation units
\begin{DoxyItemize}
\item Is it possible to make two or more translation units in single project? Assume I am calling them all into \doxylink{main_8cpp}{main.\+cpp}
\item Yes, it\textquotesingle{}s not only possible but also quite common to have multiple translation units in a single C++ project. You typically organize code into multiple source files to improve maintainability, encapsulation, and reusability. Here\textquotesingle{}s a simple illustration of how you might organize a project\+:
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ main.cpp}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}lib.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}()\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{lib\_function}}();\ \textcolor{comment}{//\ Function\ from\ lib.cpp}}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Main\ function."{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ lib.cpp}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}lib.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{lib\_function}}()\ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Function\ from\ lib."{}}\ <<\ std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ lib.h}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifndef\ LIB\_H}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ LIB\_H}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{lib\_function}}();\ \textcolor{comment}{//\ Declaration\ of\ function\ from\ lib.cpp}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ LIB\_H}}

\end{DoxyCode}


In this setup\+:


\begin{DoxyItemize}
\item {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} includes {\ttfamily lib.\+h} to know about {\ttfamily lib\+\_\+function()} and calls {\ttfamily lib\+\_\+function()} within {\ttfamily \doxylink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main()}}.
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} defines what {\ttfamily lib\+\_\+function()} actually does.
\item {\ttfamily lib.\+h} is the header file that declares {\ttfamily lib\+\_\+function()}.
\end{DoxyItemize}

Each {\ttfamily .cpp} file (\doxylink{main_8cpp}{main.\+cpp} and \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}) is a separate translation unit, and when you compile the project, each translation unit will be compiled into an object file\+:


\begin{DoxyItemize}
\item {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} -\/\texorpdfstring{$>$}{>} {\ttfamily main.\+o}
\item {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} -\/\texorpdfstring{$>$}{>} {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}
\end{DoxyItemize}

Then, during the linking stage, both object files ({\ttfamily main.\+o} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}) are linked together to form the final executable. You can compile and link these using a command-\/line interface with a compiler like g++. Here\textquotesingle{}s how it might look\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{g++\ -\/c\ main.cpp\ -\/o\ main.o}
\DoxyCodeLine{g++\ -\/c\ lib.cpp\ -\/o\ lib.o}
\DoxyCodeLine{g++\ main.o\ lib.o\ -\/o\ my\_program}

\end{DoxyCode}


The {\ttfamily -\/c} flag tells the compiler to generate object files, and the final line without {\ttfamily -\/c} links the object files into an executable called {\ttfamily my\+\_\+program}.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md78}{}\doxysubsection{\texorpdfstring{Question -\/2}{Question -2}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md78}

\begin{DoxyItemize}
\item But I thought if I call lib in main then the result will be a one single big translation unit?
\begin{DoxyItemize}
\item It seems there might be a misunderstanding about how the translation unit works in relation to including one file within another. Including one file in another (such as {\ttfamily lib.\+h} in {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}) does not merge the contents of {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} into the translation unit of {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}.
\end{DoxyItemize}
\end{DoxyItemize}

Here\textquotesingle{}s what happens when you include {\ttfamily lib.\+h} in {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}\+:


\begin{DoxyEnumerate}
\item {\bfseries{Preprocessing}}\+: The content of {\ttfamily lib.\+h} is copied into {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} during the preprocessing step. This does not include the actual definitions and implementations of functions from {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}}—only their declarations from {\ttfamily lib.\+h}.
\item {\bfseries{Compilation}}\+: Each {\ttfamily .cpp} file is compiled separately into its own object file. {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} becomes {\ttfamily main.\+o}, and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} becomes {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}. At this point, {\ttfamily main.\+o} knows that {\ttfamily lib\+\_\+function()} exists because it\textquotesingle{}s declared in {\ttfamily lib.\+h}, but it doesn\textquotesingle{}t know how it\textquotesingle{}s implemented—that\textquotesingle{}s in {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}.
\item {\bfseries{Linking}}\+: The linker then combines {\ttfamily main.\+o} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}} into a single executable. The linker resolves the references to {\ttfamily lib\+\_\+function()} in {\ttfamily main.\+o} by finding its definition in {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+o}}.
\end{DoxyEnumerate}

So, even though {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} includes {\ttfamily lib.\+h}, {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{lib.\+cpp}} remain separate translation units. They are only brought together into a single, cohesive program during the linking stage, which is after each translation unit has been compiled into an object file.\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md79}{}\doxysubsection{\texorpdfstring{Question -\/3}{Question -3}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md79}
Now, can I say in that case that for every CPP file there is a corresponding translation unit? If not then what is the reason? Is CPP file can be considered as a translation unit?

Yes, you can say that for every {\ttfamily .cpp} file, there is a corresponding translation unit in the context of compiling a C++ program. The {\ttfamily .cpp} file itself, along with all the content that gets included ({\ttfamily \#include}) and expanded (macros, inline functions, templates, etc.) during the preprocessing step, forms a single translation unit. So, each {\ttfamily .cpp} file can indeed be considered a translation unit after preprocessing. Here\textquotesingle{}s why\+:


\begin{DoxyItemize}
\item {\bfseries{Preprocessing}}\+: Each {\ttfamily .cpp} file is preprocessed individually. During this step, all included headers ({\ttfamily \#include}), macros, and conditional compilation directives are processed. The result is a single, often much larger, source code file that is then ready for compilation. This preprocessed file represents the translation unit.
\item {\bfseries{Compilation}}\+: The translation unit is compiled into an object file. The compiler translates the preprocessed C++ code into assembly, which is then turned into machine code, producing an object file ({\ttfamily .o} or {\ttfamily .obj}).
\end{DoxyItemize}

Therefore, the relationship is generally one-\/to-\/one\+: one {\ttfamily .cpp} file is preprocessed and compiled into one translation unit, which results in one object file. However, it\textquotesingle{}s worth noting that a translation unit is a conceptual part of the compilation process and doesn\textquotesingle{}t directly correspond to a physical file you can see (other than the {\ttfamily .cpp} source file and the resulting {\ttfamily .o} or {\ttfamily .obj} object file).\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md80}{}\doxysubsection{\texorpdfstring{Question -\/4}{Question -4}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md80}
Is it possible to show the .i files after the pre processor Show me an easy hello world example using clang++ command line, and point what kind of flag is needed?


\begin{DoxyItemize}
\item The {\ttfamily .i} files are the result of the C preprocessor processing the source files ({\ttfamily .cpp}). They contain the expanded source code with all the macros replaced and header files included. Here\textquotesingle{}s how you can see the {\ttfamily .i} preprocessed files using {\ttfamily clang++}.
\end{DoxyItemize}

First, let\textquotesingle{}s consider a simple "{}\+Hello, World!"{} program. You have two files\+: {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily hello.\+h}.

{\ttfamily hello.\+h}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifndef\ HELLO\_H}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ HELLO\_H}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{say\_hello}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ HELLO\_H}}

\end{DoxyCode}


{\ttfamily \doxylink{main_8cpp}{main.\+cpp}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}hello.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{say\_hello}}()\ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Hello,\ World!"{}}\ <<\ std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}()\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{say\_hello}}();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


Now, to generate the {\ttfamily .i} preprocessed file using {\ttfamily clang++}, you would use the {\ttfamily -\/E} flag, which tells the compiler to stop after the preprocessing stage. Here\textquotesingle{}s the command you would use in the terminal\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{clang++\ -\/E\ main.cpp\ -\/o\ main.i}

\end{DoxyCode}



\begin{DoxyItemize}
\item This will create a {\ttfamily main.\+i} file which contains the result of preprocessing {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}. If you open {\ttfamily main.\+i}, you will see the contents of {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} with the contents of {\ttfamily hello.\+h} included inline and all preprocessing directives executed. It will also include the content from the standard library headers like {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} that were included in {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}.
\item The {\ttfamily .i} file is not typically used in the compilation process—it\textquotesingle{}s mainly useful for debugging preprocessor issues. Normally, preprocessing is just the first step of the compilation that happens internally, and the compiler doesn\textquotesingle{}t save the intermediate result unless specifically instructed to do so with flags like {\ttfamily -\/E}.
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md81}{}\doxysubsection{\texorpdfstring{Question -\/5}{Question -5}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__how__it__works_autotoc_md81}
What is the result of main.\+i show it to me of your previous example?
\begin{DoxyItemize}
\item The {\ttfamily .i} file resulting from preprocessing {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} would contain the entire contents of {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} with all {\ttfamily \#include} directives replaced by the actual content of the included files, macros expanded, and comments removed. This file can be quite large due to the inclusion of standard library headers like {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}}.
\item For the simple {\ttfamily \doxylink{main_8cpp}{main.\+cpp}} and {\ttfamily hello.\+h} files provided earlier, the {\ttfamily main.\+i} would look similar to the original {\ttfamily \doxylink{main_8cpp}{main.\+cpp}}, but with the contents of {\ttfamily hello.\+h} copied into it and the expanded code from {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} and other headers included by it. Here is a simplified example of what the {\ttfamily main.\+i} might look like\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Contents\ of\ hello.h\ inlined\ (assuming\ hello.h\ does\ not\ include\ other\ headers)}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{say\_hello}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...Lots\ of\ system-\/specific\ code\ from\ including\ <iostream>...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{class_vector__2d}{say\_hello}}()\ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Hello,\ World!"{}}\ <<\ std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_c_make_c_x_x_compiler_id_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}()\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_vector__2d}{say\_hello}}();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...More\ system-\/specific\ code\ and\ definitions...}}

\end{DoxyCode}



\begin{DoxyItemize}
\item The preprocessor output ({\ttfamily main.\+i}) would not normally be read by humans due to its size and complexity. However, it can be useful for debugging if you need to see exactly what the preprocessor is doing with your code.
\item The actual content can be thousands of lines long because standard headers like {\ttfamily \texorpdfstring{$<$}{<}iostream\texorpdfstring{$>$}{>}} often include other headers, which in turn include even more. It\textquotesingle{}s a recursive and expansive inclusion of a large portion of the standard library. 
\end{DoxyItemize}