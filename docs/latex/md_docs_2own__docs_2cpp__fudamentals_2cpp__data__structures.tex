\chapter{C++ Data Structures Types}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures}{}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures}\index{C++ Data Structures Types@{C++ Data Structures Types}}
\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md48}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md48}%



\begin{DoxyItemize}
\item Common data structures
\item Notes
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md49}{}\doxysection{\texorpdfstring{Common data structures}{Common data structures}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md49}

\begin{DoxyItemize}
\item Here\textquotesingle{}s a simple table outlining some common data structures in C++ and where they\textquotesingle{}re typically allocated (heap vs. stack). Note that this table isn\textquotesingle{}t
\end{DoxyItemize}

{\bfseries{Table of Contents}}


\begin{DoxyItemize}
\item C++ Data Structures Types
\begin{DoxyItemize}
\item Common data structures
\item Notes
\end{DoxyItemize}

exhaustive, but it should give you a good starting point.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Structure}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Allocation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Data Structure}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Allocation}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Small Example}}    }\\\cline{1-4}
\endhead
{\bfseries{Array (fixed-\/size)}}   &Stack   &Contiguous block of memory with fixed size   &{\ttfamily int arr\mbox{[}5\mbox{]};}    \\\cline{1-4}
{\bfseries{std\+::array}}   &Stack   &Wrapper around fixed-\/size arrays   &{\ttfamily std\+::array\texorpdfstring{$<$}{<}int, 5\texorpdfstring{$>$}{>} arr;}    \\\cline{1-4}
{\bfseries{Dynamic Array}}   &Heap   &An array with dynamic size   &{\ttfamily int\texorpdfstring{$\ast$}{*} arr = new int\mbox{[}5\mbox{]};}    \\\cline{1-4}
{\bfseries{std\+::vector}}   &Heap (usually)   &Dynamic size array, grows/shrinks as needed   &{\ttfamily std\+::vector\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} vec;}    \\\cline{1-4}
{\bfseries{std\+::string}}   &Heap (usually)   &Dynamic string implementation   &{\ttfamily std\+::string str = "{}hello"{};}    \\\cline{1-4}
{\bfseries{std\+::list}}   &Heap   &Doubly-\/linked list, allows constant time insertions and deletions   &{\ttfamily std\+::list\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} lst;}    \\\cline{1-4}
{\bfseries{std\+::forward\+\_\+list}}   &Heap   &Singly-\/linked list, allows constant time insertions and deletions   &{\ttfamily std\+::forward\+\_\+list\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} flst;}    \\\cline{1-4}
{\bfseries{std\+::map}}   &Heap   &Balanced Binary Search Tree (typically Red-\/\+Black Tree)   &{\ttfamily std\+::map\texorpdfstring{$<$}{<}int, std\+::string\texorpdfstring{$>$}{>} m;}    \\\cline{1-4}
{\bfseries{std\+::unordered\+\_\+map}}   &Heap   &Hash table   &{\ttfamily std\+::unordered\+\_\+map\texorpdfstring{$<$}{<}int, std\+::string\texorpdfstring{$>$}{>} um;}    \\\cline{1-4}
{\bfseries{std\+::stack}}   &Depends on underlying container, but often heap if using {\ttfamily std\+::deque} (default)   &LIFO principle, wrapper around container   &{\ttfamily std\+::stack\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} s;}    \\\cline{1-4}
{\bfseries{std\+::queue}}   &Depends on underlying container, but often heap if using {\ttfamily std\+::deque} (default)   &FIFO principle, wrapper around container   &{\ttfamily std\+::queue\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} q;}   \\\cline{1-4}
\end{longtabu}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md50}{}\doxysection{\texorpdfstring{Notes}{Notes}}\label{md_docs_2own__docs_2cpp__fudamentals_2cpp__data__structures_autotoc_md50}

\begin{DoxyItemize}
\item Remember that {\ttfamily std\+::vector}, {\ttfamily std\+::string}, and some other standard library containers might keep small data on the stack (small string optimization for {\ttfamily std\+::string} or small buffer optimization for {\ttfamily std\+::vector}), but larger data gets moved to the heap.
\item It\textquotesingle{}s also worth noting that while the containers themselves may allocate on the heap, the container objects can be allocated on the stack. For example, when we say {\ttfamily std\+::vector\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} vec;}, the {\ttfamily vec} object is on the stack, but the underlying data it manages will typically be on the heap.
\item Whether a data structure\textquotesingle{}s storage is on the stack or heap depends on how you declare and initialize it. For instance, {\ttfamily std\+::vector\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>} \texorpdfstring{$\ast$}{*}vec\+\_\+ptr = new std\+::vector\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}();} would create the {\ttfamily std\+::vector} object on the heap. 
\end{DoxyItemize}