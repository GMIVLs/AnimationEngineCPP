\chapter{Operators in depth}
\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2operators}{}\label{md_docs_2own__docs_2cpp__fudamentals_2operators}\index{Operators in depth@{Operators in depth}}
\label{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md148}%
\Hypertarget{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md148}%
 \hypertarget{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md149}{}\doxysection{\texorpdfstring{The operator (\+::)}{The operator (::)}}\label{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md149}
The {\ttfamily \+::} symbol in C++ is known as the "{}scope resolution operator"{}. Here\textquotesingle{}s a table outlining its usages\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practice}}    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Best Practice}}    }\\\cline{1-4}
\endhead
{\bfseries{Global Namespace}}   &Accesses a global variable/function, typically when a local variable hides it.   &{\ttfamily int x = 10; void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()} \{ int x = 5; \doxylink{_s_d_l__opengl_8h_abe1577120f1766eff913e9a74879f373}{x} = 20; \}}   &Only use when necessary to differentiate between global and local variables. Avoid having too many global variables in the first place.    \\\cline{1-4}
{\bfseries{Class Static Members}}   &Accesses static members of a class.   &{\ttfamily class My\+Class \{ static int x; \}; int My\+Class\+::x = 10;}   &Always initialize static members (especially if they have non-\/trivial types). It\textquotesingle{}s usually done in a source ({\ttfamily .cpp}) file.    \\\cline{1-4}
{\bfseries{Outside Class Definition}}   &Defines a member function outside the class definition.   &{\ttfamily class My\+Class \{ void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()}; \}; void My\+Class\+::func() \{ \}}   &Keep the implementation and declaration separate. Implement member functions outside the class in the source files.    \\\cline{1-4}
{\bfseries{Nested Class or Enum}}   &Accesses a nested class or enum inside another class.   &{\ttfamily class Outer \{ class Inner \{ \}; \}; \doxylink{class_vector__2d_a6d09fb691e01f179efcbef03bef13b9c}{Outer\+::\+Inner} obj;}   &Use nested classes and enums only when the inner type has strong dependencies with the enclosing class and doesn\textquotesingle{}t make sense in a broader scope.    \\\cline{1-4}
{\bfseries{Unambiguous Base Class Member}}   &Specifies which base class\textquotesingle{}s member to use in case of multiple inheritance.   &{\ttfamily struct A \{ void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()}; \}; struct B \{ void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()}; \}; struct C \+: A, B \{ void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()} \{ A\+::func(); \} \};}   &Use sparingly. Multiple inheritance can be tricky. Prefer composition or interfaces (pure virtual classes) when possible.    \\\cline{1-4}
{\bfseries{Global Namespace Specifier}}   &Accesses the global namespace. Useful when working with libraries having common names.   &{\ttfamily namespace lib \{ void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()} \{ \} \} void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func()} \{ lib\+::func(); \}}   &When using libraries, prefer using namespace qualifiers to prevent clashes and ambiguities. Avoid {\ttfamily using namespace} in header files.    \\\cline{1-4}
{\bfseries{Template Resolution}}   &Forces the compiler to treat the name as a template.   &{\ttfamily template\texorpdfstring{$<$}{<}class T\texorpdfstring{$>$}{>} void \doxylink{_s_d_l__opengl__glext_8h_a18ae3ab36a07e388833b568cfdfa90c8}{func(\+T)} \{ \} template\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>} void func\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}(int) \{ \}}   &Use when you want to provide explicit specializations for templates. Be sure to test thoroughly, as template code can have complex interactions.    \\\cline{1-4}
{\bfseries{Name Qualification}}   &Specifies a particular namespace or class to which an identifier belongs.   &{\ttfamily namespace NS \{ int x; \} int x = NS\+::x;}   &Use namespaces to organize code and avoid name clashes. Always qualify names when it\textquotesingle{}s unclear or ambiguous which version you\textquotesingle{}re referring to.   \\\cline{1-4}
\end{longtabu}



\begin{DoxyItemize}
\item The {\ttfamily \+::} operator is fundamental in C++ to define and access specific parts of code within their defined scopes. Using it effectively helps manage the complexities of C++\textquotesingle{}s rich feature set and avoids ambiguities in the code. Always aim for clarity when using the scope resolution operator.
\end{DoxyItemize}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md150}{}\doxysection{\texorpdfstring{Binary Operators}{Binary Operators}}\label{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md150}
Here\textquotesingle{}s a continuation of the table, now including all of C++\textquotesingle{}s binary operators\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Operator}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Command/\+Effect}}    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Operator}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Command/\+Effect}}    }\\\cline{1-5}
\endhead
{\ttfamily \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<}}   &{\ttfamily x \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} n}   &{\bfseries{Left Shift}}\+: Shifts the bits of {\ttfamily x} to the left by {\ttfamily n} positions. Rightmost {\ttfamily n} bits are filled with zeros.   &{\ttfamily int x = 5; int result = x \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} 2; // 20}   &{\ttfamily 0101} shifted left by 2 positions becomes {\ttfamily 10100}    \\\cline{1-5}
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}   &{\ttfamily x \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} n}   &{\bfseries{Right Shift}}\+: Shifts bits of {\ttfamily x} to the right by {\ttfamily n} positions. Behavior depends on sign of {\ttfamily x} and type.   &{\ttfamily int x = 20; int result = x \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} 2; // 5}   &{\ttfamily 10100} shifted right by 2 positions becomes {\ttfamily 0101}    \\\cline{1-5}
{\ttfamily \&}   &{\ttfamily x \& y}   &{\bfseries{Bitwise AND}}\+: Performs a bitwise AND operation on the operands.   &{\ttfamily int result = 5 \& 3; // result is 1}   &{\ttfamily 0101} AND {\ttfamily 0011} results in {\ttfamily 0001}    \\\cline{1-5}
{\ttfamily \textbackslash{}\texorpdfstring{$\vert$}{|}}   &{\ttfamily x \textbackslash{}\texorpdfstring{$\vert$}{|} y}   &{\bfseries{Bitwise OR}}\+: Performs a bitwise OR operation on the operands.   &{\ttfamily int result = 5 \textbackslash{}\texorpdfstring{$\vert$}{|} 3; // result is 7}   &{\ttfamily 0101} OR {\ttfamily 0011} results in {\ttfamily 0111}    \\\cline{1-5}
{\ttfamily \texorpdfstring{$^\wedge$}{\string^}}   &{\ttfamily x \texorpdfstring{$^\wedge$}{\string^} y}   &{\bfseries{Bitwise XOR}}\+: Performs a bitwise exclusive OR operation on the operands.   &{\ttfamily int result = 5 \texorpdfstring{$^\wedge$}{\string^} 3; // result is 6}   &{\ttfamily 0101} XOR {\ttfamily 0011} results in {\ttfamily 0110}    \\\cline{1-5}
{\ttfamily \texorpdfstring{$\sim$}{\string~}}   &{\ttfamily \texorpdfstring{$\sim$}{\string~}x}   &{\bfseries{Bitwise NOT}}\+: Flips all the bits of the operand.   &{\ttfamily int result = \texorpdfstring{$\sim$}{\string~}5; // platform-\/dependent}   &Flips each bit of {\ttfamily 0101}, result might be {\ttfamily 1010} for an 8-\/bit int.    \\\cline{1-5}
{\ttfamily +}   &{\ttfamily x + y}   &{\bfseries{Addition}}\+: Adds two numbers.   &{\ttfamily int result = 5 + 3; // result is 8}   &Adds 5 and 3, results in 8    \\\cline{1-5}
{\ttfamily -\/}   &{\ttfamily x -\/ y}   &{\bfseries{Subtraction}}\+: Subtracts second operand from the first.   &{\ttfamily int result = 5 -\/ 3; // result is 2}   &Subtracts 3 from 5, results in 2    \\\cline{1-5}
{\ttfamily \texorpdfstring{$\ast$}{*}}   &{\ttfamily x \texorpdfstring{$\ast$}{*} y}   &{\bfseries{Multiplication}}\+: Multiplies two numbers.   &{\ttfamily int result = 5 \texorpdfstring{$\ast$}{*} 3; // result is 15}   &Multiplies 5 by 3, results in 15    \\\cline{1-5}
{\ttfamily /}   &{\ttfamily x / y}   &{\bfseries{Division}}\+: Divides the first operand by the second.   &{\ttfamily int result = 5 / 3; // result is 1}   &Divides 5 by 3, results in 1 (integer division)    \\\cline{1-5}
{\ttfamily \%}   &{\ttfamily x \% y}   &{\bfseries{Modulo}}\+: Returns the remainder of the division of the first operand by the second.   &{\ttfamily int result = 5 \% 3; // result is 2}   &Divides 5 by 3, remainder is 2   \\\cline{1-5}
\end{longtabu}


{\bfseries{Notes}}\+:


\begin{DoxyEnumerate}
\item {\bfseries{Division by Zero}}\+: Both the {\ttfamily /} and {\ttfamily \%} operators will cause undefined behavior if the second operand is zero.
\item {\bfseries{Bitwise Operations}}\+: The bitwise operations ({\ttfamily \&}, {\ttfamily \texorpdfstring{$\vert$}{|}}, {\ttfamily \texorpdfstring{$^\wedge$}{\string^}}, {\ttfamily \texorpdfstring{$\sim$}{\string~}}, {\ttfamily \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<}}, {\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}) operate on the individual bits of their operands.
\item {\bfseries{Signedness}}\+: The behavior of the shift operators and the {\ttfamily \texorpdfstring{$\sim$}{\string~}} operator can vary depending on whether the operands are signed or unsigned. Always be cautious and understand the context in which you\textquotesingle{}re using them.
\item {\bfseries{Operator Overloading}}\+: C++ allows user-\/defined types (e.\+g., classes) to provide custom implementations for these operators. This means they can perform different operations when used with objects of those types.
\end{DoxyEnumerate}

{\bfseries{Notes}}\+:


\begin{DoxyEnumerate}
\item {\bfseries{Division by Zero}}\+: Both the {\ttfamily /} and {\ttfamily \%} operators will cause undefined behavior if the second operand is zero.
\item {\bfseries{Bitwise Operations}}\+: The bitwise operations ({\ttfamily \&}, {\ttfamily \texorpdfstring{$\vert$}{|}}, {\ttfamily \texorpdfstring{$^\wedge$}{\string^}}, {\ttfamily \texorpdfstring{$\sim$}{\string~}}, {\ttfamily \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<}}, {\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}) operate on the individual bits of their operands.
\item {\bfseries{Signedness}}\+: The behavior of the shift operators and the {\ttfamily \texorpdfstring{$\sim$}{\string~}} operator can vary depending on whether the operands are signed or unsigned. Always be cautious and understand the context in which you\textquotesingle{}re using them.
\item {\bfseries{Operator Overloading}}\+: C++ allows user-\/defined types (e.\+g., classes) to provide custom implementations for these operators. This means they can perform different operations when used with objects of those types.
\end{DoxyEnumerate}\hypertarget{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md151}{}\doxysection{\texorpdfstring{Usage of Modulo operators \%}{Usage of Modulo operators \%}}\label{md_docs_2own__docs_2cpp__fudamentals_2operators_autotoc_md151}

\begin{DoxyItemize}
\item The modulo operator {\ttfamily \%} in C++ is primarily used to calculate the remainder of integer division. However, it has a wide variety of applications due to this basic functionality. Here\textquotesingle{}s a table illustrating some common use cases\+:
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Usage}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Example}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-3}
\endhead
Basic Remainder Calculation   &{\ttfamily int result = 11 \% 3; // result is 2}   &Directly computes the remainder of 11 divided by 3. The result is {\ttfamily 2} because 11 divided by 3 gives a quotient of {\ttfamily 3} with a remainder of {\ttfamily 2}.    \\\cline{1-3}
Looping/\+Cycling over Array Elements   &{\ttfamily int arr\mbox{[}5\mbox{]}; int i = 7; int pos = i \% 5; // pos is 2}   &If you need to access elements in a cyclic manner, the modulo operator can be used. Here, accessing the 7th element of a 5-\/element array actually accesses the 2nd element.    \\\cline{1-3}
Datetime (Hours)   &{\ttfamily int hours = 26; int day\+Hours = hours \% 24; // day\+Hours is 2}   &For time representation, if you exceed 24 hours, the modulo can be used to determine the hour of the next day. Here, 26 hours is equivalent to 2 hours into the next day.    \\\cline{1-3}
Datetime (Minutes, Seconds)   &{\ttfamily int mins = 130; int hour\+Mins = mins \% 60; // hour\+Mins is 10}   &Similarly, for minutes or seconds, exceeding 60 can be wrapped using modulo. Here, 130 minutes is 2 hours and 10 minutes.    \\\cline{1-3}
Checking for Even/\+Odd Numbers   &{\ttfamily bool is\+Even = (num \% 2 == 0);}   &The modulo operator can determine if a number is even or odd. If a number modulo 2 is {\ttfamily 0}, it\textquotesingle{}s even; otherwise, it\textquotesingle{}s odd.    \\\cline{1-3}
Ensuring Values within a Range   &{\ttfamily int val = -\/3; int positive\+Val = (val + N) \% N;}   &If you want to ensure a number stays within a specific range (0 to N-\/1), modulo can be helpful, especially when dealing with negative numbers.   \\\cline{1-3}
\end{longtabu}


{\bfseries{Notes}}\+:


\begin{DoxyEnumerate}
\item {\bfseries{Be Cautious with Negative Numbers}}\+: The behavior of the modulo operator with negative operands can differ between programming languages. In C++, {\ttfamily -\/3 \% 5} will yield {\ttfamily -\/3}, not {\ttfamily 2}. If you want a "{}positive"{} result, you might need to adjust the operand or the result as shown in the last usage example.
\item {\bfseries{Non-\/\+Integer Types}}\+: In C++, the modulo operator is defined only for integral types. It\textquotesingle{}s not directly applicable to floating-\/point types, although libraries or custom logic can be used to achieve similar effects.
\item {\bfseries{Zero Division}}\+: Just like with division, using the modulo operator with a denominator of {\ttfamily 0} will result in undefined behavior in C++. Always ensure your denominator is non-\/zero. 
\end{DoxyEnumerate}